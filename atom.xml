<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lvzhh&#39;s Blog</title>
  
  <subtitle>a memo</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lvzhh.github.io/"/>
  <updated>2018-06-18T02:48:24.459Z</updated>
  <id>http://lvzhh.github.io/</id>
  
  <author>
    <name>Lvzhh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UVA 1572 Self-Assembly</title>
    <link href="http://lvzhh.github.io/2018/06/UVA-1572-Self-Assembly/"/>
    <id>http://lvzhh.github.io/2018/06/UVA-1572-Self-Assembly/</id>
    <published>2018-06-18T01:55:44.000Z</published>
    <updated>2018-06-18T02:48:24.459Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给n个正方形分子，分子的边在一定条件下可以结合，求这些分子能不能形成无穷大的结构。</p><p>我们从分子的某条边开始铺，假设从下图中的边K+开始铺。K+与K-相结合，再下一步，可以从C-、D+、D+边铺。假设D+与D-相结合后，结合的分子有一条边为K+，那么下一步可以从此K+边开始。问题又回到了起点，按照与之前相同的选择，可以不断重复而组合成无穷大的结构。也就是说，如果从某条边开始，不断地铺，能够到达一条跟它有相同标号的边，那么能够形成无穷大的结构；否则，不能够形成。<br><img src="/2018/06/UVA-1572-Self-Assembly/10.png"></p><p>考虑以图来建模，把标号作为结点，结点的数目最多有26*2个（不考虑00，因为00不可能在有向圈上）。假设正方形的四条边的标号分别为abcd，记dual(a)表示可以和标号a相结合的标号（如K+和K-可以结合），那么dual(a)可以到达b，dual(b)可以到达a…。问题转化为了找有向图中是否存在有向圈，用拓扑排序可以做。</p><p>PS：把dual函数修改了后从50ms到了40ms，rank top 了…<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dual</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (v &amp; <span class="number">1</span>) ? v - <span class="number">1</span> : v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dual</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">26</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ID00 = <span class="number">26</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> G[V][V];</span><br><span class="line"><span class="keyword">int</span> c[V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  c[v] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!G[v][u]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[u] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c[u] == <span class="number">0</span> &amp;&amp; !dfs(u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[v] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c[v] == <span class="number">0</span> &amp;&amp; !dfs(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dual</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] == <span class="string">'0'</span>) id[j / <span class="number">2</span>] = <span class="number">26</span> * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> id[j / <span class="number">2</span>] = (s[j] - <span class="string">'A'</span>) * <span class="number">2</span> + (s[j + <span class="number">1</span>] == <span class="string">'+'</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id[j] == ID00) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> u = dual(id[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (k == j || id[k] == ID00) <span class="keyword">continue</span>;</span><br><span class="line">          G[u][id[k]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, solve() ? <span class="string">"bounded"</span> : <span class="string">"unbounded"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给n个正方形分子，分子的边在一定条件下可以结合，求这些分子能不能形成无穷大的结构。&lt;/p&gt;
&lt;p&gt;我们从分子的某条边开始铺，假设从下图中的边K+开始铺。K+与K-相结合，再下一步，可以从C-、D+、D+边铺。假设D+与D-相结合后，结合的分子有一条边为K+，那么下一步可以从此K+边开始。问题又回到了起点，按照与之前相同的选择，可以不断重复而组合成无穷大的结构。也就是说，如果从某条边开始，不断地铺，能够到达一条跟它有相同标号的边，那么能够形成无穷大的结构；否则，不能够形成。&lt;br&gt;
&lt;img src=&quot;/2018/06/UVA-1572-Self-Assembly/10.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;考虑以图来建模，把标号作为结点，结点的数目最多有26*2个（不考虑00，因为00不可能在有向圈上）。假设正方形的四条边的标号分别为abcd，记dual(a)表示可以和标号a相结合的标号（如K+和K-可以结合），那么dual(a)可以到达b，dual(b)可以到达a…。问题转化为了找有向图中是否存在有向圈，用拓扑排序可以做。&lt;/p&gt;
&lt;p&gt;PS：把dual函数修改了后从50ms到了40ms，rank top 了…&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://lvzhh.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="拓扑排序" scheme="http://lvzhh.github.io/categories/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
      <category term="WF" scheme="http://lvzhh.github.io/tags/WF/"/>
    
  </entry>
  
  <entry>
    <title>UVA 1599 Ideal Path</title>
    <link href="http://lvzhh.github.io/2018/06/UVA-1599-Ideal-Path/"/>
    <id>http://lvzhh.github.io/2018/06/UVA-1599-Ideal-Path/</id>
    <published>2018-06-17T15:45:38.000Z</published>
    <updated>2018-06-18T02:48:00.769Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个n个顶点m条边的无向图，图中可能有多重边和自环。求顶点1到顶点n最少需要经过的边数，并且输出字典序最小的边的颜色序列。</p><p>从顶点1到顶点n的最少边数可以通过BFS求得，关键是字典序最小的颜色序列。想到的做法是，<strong>从顶点n到顶点1</strong>进行BFS，得到每个顶点与顶点n的距离。之后，想象按照距离把图分层，然后从顶点1开始，每往下走一层，都选择颜色值最小的边。</p><p>若是<strong>从顶点1到顶点n</strong>进行BFS，之后再按照到顶点1的距离分层，在往下一层走时，假设某条边e(u,v)的颜色值最小，我们选择了边e，但是顶点v到顶点n可能需要（比最少边数）更多的边数！</p><p>一个坑：因为图中存在多重边，假设我们从顶点u往下一层走时，选择的最小颜色值与边e(u,v)相同，且有3000条颜色值相同的边e(u,v)，那么结点v要入队（这里使用队列维护）3000次！因此，需要保证入队一次，不然空间和时间都会爆炸<span class="github-emoji" title="smile" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = ~<span class="number">0U</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> to, c; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> dist[MAX_V], prevv[MAX_V], color[MAX_V];</span><br><span class="line"><span class="keyword">bool</span> inque[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  dist[n] = <span class="number">0</span>;</span><br><span class="line">  que.push(n);</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = que.front(); que.pop();</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">      Edge&amp; e = G[v][i];</span><br><span class="line">      <span class="keyword">int</span> u = e.to;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] + <span class="number">1</span> &lt; dist[u]) &#123;</span><br><span class="line">        dist[u] = dist[v] + <span class="number">1</span>;</span><br><span class="line">        que.push(u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> level = dist[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memset</span>(inque, <span class="number">0</span>, <span class="keyword">sizeof</span>(inque));</span><br><span class="line">  inque[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (level--) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = que.size();</span><br><span class="line">    <span class="keyword">int</span> cmin = INF;</span><br><span class="line">    <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = que.front();</span><br><span class="line">      que.pop(); que.push(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">        Edge&amp; e = G[v][i];</span><br><span class="line">        <span class="keyword">int</span> u = e.to;</span><br><span class="line">        <span class="keyword">if</span> (dist[u] != dist[v] - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cmin = min(cmin, e.c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size = que.size();</span><br><span class="line">    <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = que.front(); que.pop();</span><br><span class="line">      inque[v] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">        Edge&amp; e = G[v][i];</span><br><span class="line">        <span class="keyword">int</span> u = e.to;</span><br><span class="line">        <span class="keyword">if</span> (dist[u] != dist[v] - <span class="number">1</span> || e.c != cmin || inque[u]) <span class="keyword">continue</span>;</span><br><span class="line">        que.push(u);</span><br><span class="line">        prevv[u] = v;</span><br><span class="line">        color[u] = e.c;</span><br><span class="line">        inque[u] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, c;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      G[a].push_back((Edge) &#123;b, c&#125;);</span><br><span class="line">      G[b].push_back((Edge) &#123;a, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    rbfs();</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = n; v != <span class="number">1</span>; v = prevv[v]) &#123;</span><br><span class="line">      ans.push_back(color[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], i == <span class="number">0</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给定一个n个顶点m条边的无向图，图中可能有多重边和自环。求顶点1到顶点n最少需要经过的边数，并且输出字典序最小的边的颜色序列。&lt;/p&gt;
&lt;p&gt;从顶点1到顶点n的最少边数可以通过BFS求得，关键是字典序最小的颜色序列。想到的做法是，&lt;strong&gt;从顶点n到顶点1&lt;/strong&gt;进行BFS，得到每个顶点与顶点n的距离。之后，想象按照距离把图分层，然后从顶点1开始，每往下走一层，都选择颜色值最小的边。&lt;/p&gt;
&lt;p&gt;若是&lt;strong&gt;从顶点1到顶点n&lt;/strong&gt;进行BFS，之后再按照到顶点1的距离分层，在往下一层走时，假设某条边e(u,v)的颜色值最小，我们选择了边e，但是顶点v到顶点n可能需要（比最少边数）更多的边数！&lt;/p&gt;
&lt;p&gt;一个坑：因为图中存在多重边，假设我们从顶点u往下一层走时，选择的最小颜色值与边e(u,v)相同，且有3000条颜色值相同的边e(u,v)，那么结点v要入队（这里使用队列维护）3000次！因此，需要保证入队一次，不然空间和时间都会爆炸&lt;span class=&quot;github-emoji&quot; title=&quot;smile&quot; data-src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8&quot;&gt;😄&lt;/span&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="搜索" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="BFS" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/BFS/"/>
    
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
  </entry>
  
  <entry>
    <title>UVA 12171 Sculpture</title>
    <link href="http://lvzhh.github.io/2018/06/UVA-12171-Sculpture/"/>
    <id>http://lvzhh.github.io/2018/06/UVA-12171-Sculpture/</id>
    <published>2018-06-16T12:03:08.000Z</published>
    <updated>2018-06-18T02:52:58.037Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定n个长方体，求这些长方体组合成的物体的表面积和体积。想象组合后的几何体完全浸泡在水中，所求的即为几何体与水接触的面积以及所占据的体积。</p><p>可以考虑在坐标系中一个点一个点填充几何体，然后DFS标记出“水区域”。这样，与“水区域”接触的几何体的面积即为所求的表面积，非“水区域”的体积即为所求的体积。因为所给的坐标范围比较大，但n的范围比较小，需要对坐标进行离散化处理。</p><p>离散化的一些细节：若所给区间为<code>[x,y]</code>，<code>S</code>为所有坐标点排序后的数组，考虑下面两种：<br><a id="more"></a></p><ol type="1"><li>离散区间<code>[x,y+1)</code>，写为<code>[x,z)</code>，<code>S</code>中包含的为所有的<code>x</code>和<code>z</code>。考虑两个区间<code>[1,5),[6,11)</code>，填充之后如下图所示，离散坐标<code>i</code>所表示的区间长度为<code>S[i+1]-S[i]</code>，且两个区间中间的部分<code>[5,6)</code>能够表示为未填充的状态。<br><img src="/2018/06/UVA-12171-Sculpture/10.png" alt="图1"></li><li>离散区间<code>[x,y]</code>，<code>S</code>中包含的为所有的<code>x</code>和<code>y</code>。考虑相同的两个区间<code>[1,4],[6,10]</code>，填充之后如下图所示。离散坐标<code>i</code>所表示的区间长度不能统一表示，需要增加一些额外的坐标点来处理。且两个区间中间的部分<code>[5,5]</code>不能表示出状态，也需要增加一些额外的坐标点来处理。<br><img src="/2018/06/UVA-12171-Sculpture/11.png"></li></ol><p>选用第一种离散化的做法，添加0坐标使”水区域“连通。空间坐标<span class="math inline">\((i,j,k)\)</span>所表示的体积为<span class="math inline">\((X[i+1]-X[i])*(Y[i+1]-Y[i])*(Z[i+1]-Z[i])\)</span>。</p><p>也记一下第二种离散做法遇到的错误。line 99 <code>X[sx++] = X[t] + 1;</code>，最初写的是<code>X[sx++] = X[sx - 2] + 1</code>，没有达到预期的结果，且使得line 22 的<code>assert</code>不成立。没有找到原因，可能是编译的问题，导致数组下标不是所想表示的下标？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_X = MAX_N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span> &#123;</span> <span class="keyword">int</span> x0, y0, z0, x, y, z; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Box S[MAX_N];</span><br><span class="line"><span class="keyword">int</span> X[MAX_X], Y[MAX_X], Z[MAX_X], sx, sy, sz;</span><br><span class="line"><span class="keyword">bool</span> space[MAX_X][MAX_X][MAX_X];</span><br><span class="line"><span class="keyword">int</span> cmp[MAX_X][MAX_X][MAX_X];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> z0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> z1)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = x0; x &lt; x1; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = y0; y &lt; y1; y++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> z = z0; z &lt; z1; z++) &#123;</span><br><span class="line">        space[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  cmp[x][y][z] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; sx &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; sy &amp;&amp;</span><br><span class="line">        <span class="number">0</span> &lt;= nz &amp;&amp; nz &lt; sz &amp;&amp; !space[nx][ny][nz] &amp;&amp; cmp[nx][ny][nz] == <span class="number">0</span>) &#123;</span><br><span class="line">      dfs(nx, ny, nz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sx; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sy; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sz; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">6</span>; m++) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = i + dx[m], y = j + dy[m], z = k + dz[m];</span><br><span class="line">          <span class="keyword">if</span> (cmp[x][y][z]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dx[m]) s += (Y[j + <span class="number">1</span>] - Y[j]) * (Z[k + <span class="number">1</span>] - Z[k]);</span><br><span class="line">            <span class="keyword">if</span> (dy[m]) s += (X[i + <span class="number">1</span>] - X[i]) * (Z[k + <span class="number">1</span>] - Z[k]);</span><br><span class="line">            <span class="keyword">if</span> (dz[m]) s += (X[i + <span class="number">1</span>] - X[i]) * (Y[j + <span class="number">1</span>] - Y[j]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sx; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sy; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sz; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">        s += (X[i + <span class="number">1</span>] - X[i]) * (Y[j + <span class="number">1</span>] - Y[j]) * (Z[k + <span class="number">1</span>] - Z[k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discrete</span><span class="params">(<span class="keyword">int</span>* X, <span class="keyword">int</span>&amp; sx)</span> </span>&#123;</span><br><span class="line">  X[sx++] = <span class="number">0</span>;</span><br><span class="line">  sort(X, X + sx);</span><br><span class="line">  <span class="keyword">if</span> (sx != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sx; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (X[i] != X[i - <span class="number">1</span>]) X[m++] = X[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sx = m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      Box&amp; b = S[i];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d %d"</span>, &amp;b.x0, &amp;b.y0, &amp;b.z0, &amp;b.x, &amp;b.y, &amp;b.z);</span><br><span class="line">    &#125;</span><br><span class="line">    sx = sy = sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      Box&amp; b = S[i];</span><br><span class="line">      X[sx++] = b.x0; X[sx++] = b.x0 + b.x;</span><br><span class="line">      Y[sy++] = b.y0; Y[sy++] = b.y0 + b.y;</span><br><span class="line">      Z[sz++] = b.z0; Z[sz++] = b.z0 + b.z;</span><br><span class="line">    &#125;</span><br><span class="line">    discrete(X, sx);</span><br><span class="line">    discrete(Y, sy);</span><br><span class="line">    discrete(Z, sz);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(space, <span class="number">0</span>, <span class="keyword">sizeof</span>(space));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      Box&amp; b = S[i];</span><br><span class="line">      <span class="keyword">int</span> x0 = lower_bound(X, X + sx, b.x0) - X;</span><br><span class="line">      <span class="keyword">int</span> y0 = lower_bound(Y, Y + sy, b.y0) - Y;</span><br><span class="line">      <span class="keyword">int</span> z0 = lower_bound(Z, Z + sz, b.z0) - Z;</span><br><span class="line">      <span class="keyword">int</span> x1 = lower_bound(X, X + sx, b.x0 + b.x) - X;</span><br><span class="line">      <span class="keyword">int</span> y1 = lower_bound(Y, Y + sy, b.y0 + b.y) - Y;</span><br><span class="line">      <span class="keyword">int</span> z1 = lower_bound(Z, Z + sz, b.z0 + b.z) - Z;</span><br><span class="line">      fill(x0, y0, z0, x1, y1, z1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(cmp));</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, area(), volume());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_X = MAX_N * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span> &#123;</span> <span class="keyword">int</span> x0, y0, z0, x, y, z; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Box S[MAX_N];</span><br><span class="line"><span class="keyword">int</span> X[MAX_X], Y[MAX_X], Z[MAX_X], sx, sy, sz;</span><br><span class="line"><span class="keyword">bool</span> space[MAX_X][MAX_X][MAX_X];</span><br><span class="line"><span class="keyword">int</span> cmp[MAX_X][MAX_X][MAX_X];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> z0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> z1)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = x0; x &lt;= x1; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = y0; y &lt;= y1; y++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> z = z0; z &lt;= z1; z++) &#123;</span><br><span class="line">        space[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">        assert(x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; z &gt;= <span class="number">1</span>);</span><br><span class="line">        assert(x &lt;= sx - <span class="number">2</span> &amp;&amp; y &lt;= sy - <span class="number">2</span> &amp;&amp; z &lt;= sz - <span class="number">2</span>);</span><br><span class="line"><span class="comment">//        assert(x &gt;= 1 &amp;&amp; x &lt;= sx - 1 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= sy - 1 &amp;&amp; z &gt;= 1 &amp;&amp; z &lt;= sz - 1);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  cmp[x][y][z] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; sx &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; sy &amp;&amp;</span><br><span class="line">        <span class="number">0</span> &lt;= nz &amp;&amp; nz &lt; sz &amp;&amp; !space[nx][ny][nz] &amp;&amp; cmp[nx][ny][nz] == <span class="number">0</span>) &#123;</span><br><span class="line">      dfs(nx, ny, nz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sx; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sy; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sz; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">6</span>; m++) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = i + dx[m], y = j + dy[m], z = k + dz[m];</span><br><span class="line">          <span class="keyword">if</span> (cmp[x][y][z]) &#123;</span><br><span class="line"><span class="comment">//            assert(i + 1 &lt; sx);</span></span><br><span class="line"><span class="comment">//            assert(j + 1 &lt; sy);</span></span><br><span class="line"><span class="comment">//            assert(k + 1 &lt; sz);</span></span><br><span class="line">            <span class="keyword">if</span> (dx[m]) s += (Y[j + <span class="number">1</span>] - Y[j]) * (Z[k + <span class="number">1</span>] - Z[k]);</span><br><span class="line">            <span class="keyword">if</span> (dy[m]) s += (X[i + <span class="number">1</span>] - X[i]) * (Z[k + <span class="number">1</span>] - Z[k]);</span><br><span class="line">            <span class="keyword">if</span> (dz[m]) s += (X[i + <span class="number">1</span>] - X[i]) * (Y[j + <span class="number">1</span>] - Y[j]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sx; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sy; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sz; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//        assert(i + 1 &lt; sx);</span></span><br><span class="line"><span class="comment">//        assert(j + 1 &lt; sy);</span></span><br><span class="line"><span class="comment">//        assert(k + 1 &lt; sz);</span></span><br><span class="line">        s += (X[i + <span class="number">1</span>] - X[i]) * (Y[j + <span class="number">1</span>] - Y[j]) * (Z[k + <span class="number">1</span>] - Z[k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discrete</span><span class="params">(<span class="keyword">int</span>* X, <span class="keyword">int</span>&amp; sx)</span> </span>&#123;</span><br><span class="line">  X[sx++] = <span class="number">0</span>;</span><br><span class="line">  sort(X, X + sx);</span><br><span class="line">  <span class="keyword">if</span> (sx != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sx; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (X[i] != X[i - <span class="number">1</span>]) X[m++] = X[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sx = m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = sx - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (X[i + <span class="number">1</span>] != X[i] + <span class="number">1</span>) X[sx++] = X[i] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(X, X + sx);</span><br><span class="line">  <span class="keyword">int</span> t = sx - <span class="number">1</span>;</span><br><span class="line">  assert(sx &gt;= <span class="number">1</span>);</span><br><span class="line">  X[sx++] = X[t] + <span class="number">1</span>; <span class="comment">// adding a boundary, for convenience</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      Box&amp; b = S[i];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d %d"</span>, &amp;b.x0, &amp;b.y0, &amp;b.z0, &amp;b.x, &amp;b.y, &amp;b.z);</span><br><span class="line">    &#125;</span><br><span class="line">    sx = sy = sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      Box&amp; b = S[i];</span><br><span class="line">      X[sx++] = b.x0; X[sx++] = b.x0 + b.x - <span class="number">1</span>;</span><br><span class="line">      Y[sy++] = b.y0; Y[sy++] = b.y0 + b.y - <span class="number">1</span>;</span><br><span class="line">      Z[sz++] = b.z0; Z[sz++] = b.z0 + b.z - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    discrete(X, sx);</span><br><span class="line">    discrete(Y, sy);</span><br><span class="line">    discrete(Z, sz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; sx; i++) cout &lt;&lt; X[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; sy; i++) cout &lt;&lt; Y[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; sz; i++) cout &lt;&lt; Z[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(space, <span class="number">0</span>, <span class="keyword">sizeof</span>(space));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      Box&amp; b = S[i];</span><br><span class="line">      <span class="keyword">int</span> x0 = lower_bound(X, X + sx, b.x0) - X;</span><br><span class="line">      <span class="keyword">int</span> y0 = lower_bound(Y, Y + sy, b.y0) - Y;</span><br><span class="line">      <span class="keyword">int</span> z0 = lower_bound(Z, Z + sz, b.z0) - Z;</span><br><span class="line">      <span class="keyword">int</span> x1 = lower_bound(X, X + sx, b.x0 + b.x - <span class="number">1</span>) - X;</span><br><span class="line">      <span class="keyword">int</span> y1 = lower_bound(Y, Y + sy, b.y0 + b.y - <span class="number">1</span>) - Y;</span><br><span class="line">      <span class="keyword">int</span> z1 = lower_bound(Z, Z + sz, b.z0 + b.z - <span class="number">1</span>) - Z;</span><br><span class="line"><span class="comment">//      printf("%d %d %d %d %d %d\n", x0, y0, z0, x1, y1, z1);</span></span><br><span class="line">      fill(x0, y0, z0, x1, y1, z1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(cmp));</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, area(), volume());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给定n个长方体，求这些长方体组合成的物体的表面积和体积。想象组合后的几何体完全浸泡在水中，所求的即为几何体与水接触的面积以及所占据的体积。&lt;/p&gt;
&lt;p&gt;可以考虑在坐标系中一个点一个点填充几何体，然后DFS标记出“水区域”。这样，与“水区域”接触的几何体的面积即为所求的表面积，非“水区域”的体积即为所求的体积。因为所给的坐标范围比较大，但n的范围比较小，需要对坐标进行离散化处理。&lt;/p&gt;
&lt;p&gt;离散化的一些细节：若所给区间为&lt;code&gt;[x,y]&lt;/code&gt;，&lt;code&gt;S&lt;/code&gt;为所有坐标点排序后的数组，考虑下面两种：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="搜索" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/DFS/"/>
    
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
  </entry>
  
  <entry>
    <title>UVA 10305 Ordering Tasks</title>
    <link href="http://lvzhh.github.io/2018/06/UVA-10305-Ordering-Tasks/"/>
    <id>http://lvzhh.github.io/2018/06/UVA-10305-Ordering-Tasks/</id>
    <published>2018-06-14T14:40:55.000Z</published>
    <updated>2018-06-14T15:16:19.838Z</updated>
    
    <content type="html"><![CDATA[<p>拓扑排序的模板题，主要是来学习一下用DFS来判断是否有环，以及输出拓扑排序的序列。用DFS进行拓扑排序需要借助一个标记<code>c[v]</code>，<code>c[v]=0</code>表示图中的结点未被访问过，<code>c[v]=1</code>表示正在访问结点（及其后继），<code>c[v]=2</code>表示结点访问完成。（当然，也可以设置为其他有相同含义的不同的数值。）</p><p>有向图中存在环，当且仅当访问到一个结点<code>v</code>有<code>c[v]=1</code>。证：设当前正在访问结点<code>u</code>，其直接后继<code>v</code>满足<code>c[v]=1</code>，那么一定存在一条从<code>v</code>到<code>u</code>的路径，又存在有向边<code>(u,v)</code>，则图中存在环。若<code>c[v]!=1</code>，那么不存在从<code>v</code>到<code>u</code>的路径，也就没有环。</p><p>另一种比较熟悉的做法是不断从图中删去入度为0的结点，并把其加入拓扑序列。如果图中剩余的所有结点都不满足入度为0，则说明图中存在环。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> c[MAX_V];</span><br><span class="line"><span class="keyword">int</span> seq[MAX_V], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  c[v] = <span class="number">1</span>; <span class="comment">// accessing</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = G[v][i];</span><br><span class="line">    <span class="keyword">if</span> (c[u] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c[u] == <span class="number">0</span> &amp;&amp; !dfs(u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[v] = <span class="number">2</span>; <span class="comment">// accessed</span></span><br><span class="line">  seq[idx--] = v; <span class="comment">// v should be before all its successor</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">  idx = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c[v] == <span class="number">0</span> &amp;&amp; !dfs(v))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) &amp;&amp; (n || m)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) G[v].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">      G[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toposort()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, seq[i], i == n - <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> indeg[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) &amp;&amp; (n || m)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) G[v].clear();</span><br><span class="line">    <span class="built_in">memset</span>(indeg, <span class="number">0</span>, <span class="keyword">sizeof</span>(indeg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">      G[u].push_back(v);</span><br><span class="line">      indeg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) que.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = que.front(); que.pop();</span><br><span class="line">      ans.push_back(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = G[v][i];</span><br><span class="line">        indeg[u]--;</span><br><span class="line">        <span class="keyword">if</span> (indeg[u] == <span class="number">0</span>) que.push(u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], i == ans.size() - <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拓扑排序的模板题，主要是来学习一下用DFS来判断是否有环，以及输出拓扑排序的序列。用DFS进行拓扑排序需要借助一个标记&lt;code&gt;c[v]&lt;/code&gt;，&lt;code&gt;c[v]=0&lt;/code&gt;表示图中的结点未被访问过，&lt;code&gt;c[v]=1&lt;/code&gt;表示正在访问结点（及其后继），&lt;code&gt;c[v]=2&lt;/code&gt;表示结点访问完成。（当然，也可以设置为其他有相同含义的不同的数值。）&lt;/p&gt;
&lt;p&gt;有向图中存在环，当且仅当访问到一个结点&lt;code&gt;v&lt;/code&gt;有&lt;code&gt;c[v]=1&lt;/code&gt;。证：设当前正在访问结点&lt;code&gt;u&lt;/code&gt;，其直接后继&lt;code&gt;v&lt;/code&gt;满足&lt;code&gt;c[v]=1&lt;/code&gt;，那么一定存在一条从&lt;code&gt;v&lt;/code&gt;到&lt;code&gt;u&lt;/code&gt;的路径，又存在有向边&lt;code&gt;(u,v)&lt;/code&gt;，则图中存在环。若&lt;code&gt;c[v]!=1&lt;/code&gt;，那么不存在从&lt;code&gt;v&lt;/code&gt;到&lt;code&gt;u&lt;/code&gt;的路径，也就没有环。&lt;/p&gt;
&lt;p&gt;另一种比较熟悉的做法是不断从图中删去入度为0的结点，并把其加入拓扑序列。如果图中剩余的所有结点都不满足入度为0，则说明图中存在环。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://lvzhh.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="拓扑排序" scheme="http://lvzhh.github.io/categories/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="template" scheme="http://lvzhh.github.io/tags/template/"/>
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
  </entry>
  
  <entry>
    <title>UVA 1103 Ancient Messages</title>
    <link href="http://lvzhh.github.io/2018/06/UVA-1103-Ancient-Messages/"/>
    <id>http://lvzhh.github.io/2018/06/UVA-1103-Ancient-Messages/</id>
    <published>2018-06-14T09:47:17.000Z</published>
    <updated>2018-06-14T11:15:57.596Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个黑白图片的16进制表示，识别出图片中包含的象形文字。</p><p>首先需要把十六进制表示转化为二进制表示。因为每个象形文字的黑色像素是连通的，所以黑色像素的连通分量的数目即为象形文字的数目。各象形文字可以用其包含的白色区域的数目来区别。想到的做法是，dfs填充白色像素区域，并返回区域的边界：0 表示没有边界（边界都是白色像素），1,2,3… 表示边界是对应的黑色连通分量，-1 表示边界是整个图像的边界。若边界是黑色像素，则对应的黑色连通分量包含的白色区域数+1。这样，即可区分出不同的象形文字。</p><p>一个想错的地方是，认为返回的区域边界不会为0。想象这样一种情况，一个白色像素其周围的三个白色像素都已经遍历到，则返回0。而这种情况是有可能的。</p><p>紫书中的做法是增加了白色边界，方便处理；从黑色区域找与其相连的白色区域。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_H = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_W = <span class="number">50</span> * <span class="number">4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H, W;</span><br><span class="line"><span class="keyword">char</span> image[MAX_H][MAX_W];</span><br><span class="line"><span class="keyword">int</span> cmp[MAX_H][MAX_W];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">to_int</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">'9'</span>) <span class="keyword">return</span> ch - <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span> + ch - <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dX[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dY[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  cmp[x][y] = c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nx = x + dX[i], ny = y + dY[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; H &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; W &amp;&amp;</span><br><span class="line">        image[nx][ny] == <span class="string">'1'</span> &amp;&amp; cmp[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">      dfs(nx, ny, c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  cmp[x][y] = c;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nx = x + dX[i], ny = y + dY[i];</span><br><span class="line">    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= H || ny &lt; <span class="number">0</span> || ny &gt;= W) &#123;</span><br><span class="line">      b = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (image[nx][ny] == <span class="string">'1'</span>) &#123;</span><br><span class="line">      b = b == <span class="number">-1</span> ? b : cmp[nx][ny];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmp[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> r = fill(nx, ny, c);</span><br><span class="line">      <span class="comment">// order 0 &lt; 1,2,3... &lt; -1</span></span><br><span class="line">      b = r == <span class="number">-1</span> ? r : (b == <span class="number">-1</span> ? b : max(b, r));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b; <span class="comment">// b maybe 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;H, &amp;W) &amp;&amp; H) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(image, <span class="number">0</span>, <span class="keyword">sizeof</span>(image));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; H; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, image[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = W - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">int</span> t = to_int(image[i][j]);</span><br><span class="line">          image[i][(j + <span class="number">1</span>) * <span class="number">4</span> - <span class="number">1</span> - k] = ((t &gt;&gt; k) &amp; <span class="number">1</span>) ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    W = W * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(cmp));</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; W; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (image[i][j] == <span class="string">'1'</span> &amp;&amp; cmp[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">          dfs(i, j, ++num);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; area(num + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; W; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (image[i][j] == <span class="string">'0'</span> &amp;&amp; cmp[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> b = fill(i, j, ++num);</span><br><span class="line">          <span class="keyword">if</span> (b != <span class="number">-1</span>) area[b]++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ans;</span><br><span class="line">    <span class="keyword">char</span> mp[] = &#123;<span class="string">'W'</span>, <span class="string">'A'</span>, <span class="string">'K'</span>, <span class="string">'J'</span>, <span class="string">'S'</span>, <span class="string">'D'</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; area.size(); i++) &#123;</span><br><span class="line">      ans.push_back(mp[area[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, T++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给定一个黑白图片的16进制表示，识别出图片中包含的象形文字。&lt;/p&gt;
&lt;p&gt;首先需要把十六进制表示转化为二进制表示。因为每个象形文字的黑色像素是连通的，所以黑色像素的连通分量的数目即为象形文字的数目。各象形文字可以用其包含的白色区域的数目来区别。想到的做法是，dfs填充白色像素区域，并返回区域的边界：0 表示没有边界（边界都是白色像素），1,2,3… 表示边界是对应的黑色连通分量，-1 表示边界是整个图像的边界。若边界是黑色像素，则对应的黑色连通分量包含的白色区域数+1。这样，即可区分出不同的象形文字。&lt;/p&gt;
&lt;p&gt;一个想错的地方是，认为返回的区域边界不会为0。想象这样一种情况，一个白色像素其周围的三个白色像素都已经遍历到，则返回0。而这种情况是有可能的。&lt;/p&gt;
&lt;p&gt;紫书中的做法是增加了白色边界，方便处理；从黑色区域找与其相连的白色区域。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="搜索" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/DFS/"/>
    
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
  </entry>
  
  <entry>
    <title>UVA 297 Quadtrees</title>
    <link href="http://lvzhh.github.io/2018/06/UVA-297-Quadtrees/"/>
    <id>http://lvzhh.github.io/2018/06/UVA-297-Quadtrees/</id>
    <published>2018-06-14T02:43:04.000Z</published>
    <updated>2018-06-14T11:16:12.377Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定两个四分树的先序遍历序列，四分树的每个结点与图像的某个区域对应，求两个图像合并后黑色像素的数目。</p><p>想到的做法是同时遍历两个四分树，在遍历的过程中遇到<code>p</code>结点则向下；如果两个结点都不是<code>p</code>结点且其中一个为<code>f</code>结点，则加上对应区域的像素数目。</p><p>紫书中的解法是考虑四分树对应的图像。一个学到的地方是（正方形）区域的表示：区域的左上角坐标<code>(x,y)</code>以及区域的宽度<code>w</code>。这样，在表示四分区域时非常方便。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[MAX_N], s2[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">(<span class="keyword">int</span>&amp; i, <span class="keyword">int</span> d1, <span class="keyword">int</span>&amp; j, <span class="keyword">int</span> d2, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> p1 = s1[i] == <span class="string">'p'</span>, p2 = s2[j] == <span class="string">'p'</span>;</span><br><span class="line">  <span class="keyword">if</span> (p1 || p2) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">      scan(p1 ? ++i : i, p1 ? d1 - <span class="number">1</span> : d1,</span><br><span class="line">           p2 ? ++j : j, p2 ? d2 - <span class="number">1</span> : d2,</span><br><span class="line">           ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1[i] == <span class="string">'f'</span> || s2[j] == <span class="string">'f'</span>) &#123;</span><br><span class="line">      ans += (<span class="number">1</span> &lt;&lt; min(d1, d2)) * (<span class="number">1</span> &lt;&lt; min(d1, d2));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, s1, s2);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    scan(i, <span class="number">5</span>, j, <span class="number">5</span>, ans);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"There are %d black pixels.\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> W = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[MAX_N], s2[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> pic[W][W];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span>&amp; p, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s[p] == <span class="string">'p'</span>) &#123;</span><br><span class="line">    draw(s, ++p, x, y + w / <span class="number">2</span>, w / <span class="number">2</span>);</span><br><span class="line">    draw(s, ++p, x, y, w / <span class="number">2</span>);</span><br><span class="line">    draw(s, ++p, x + w / <span class="number">2</span>, y, w / <span class="number">2</span>);</span><br><span class="line">    draw(s, ++p, x + w / <span class="number">2</span>, y + w / <span class="number">2</span>, w / <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[p] == <span class="string">'f'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        pic[x + i][y + j] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, s1, s2);</span><br><span class="line">    <span class="built_in">memset</span>(pic, <span class="number">0</span>, <span class="keyword">sizeof</span>(pic));</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    draw(s1, p, <span class="number">0</span>, <span class="number">0</span>, W);</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    draw(s2, p, <span class="number">0</span>, <span class="number">0</span>, W);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; W; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; W; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pic[i][j]) ans++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"There are %d black pixels.\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给定两个四分树的先序遍历序列，四分树的每个结点与图像的某个区域对应，求两个图像合并后黑色像素的数目。&lt;/p&gt;
&lt;p&gt;想到的做法是同时遍历两个四分树，在遍历的过程中遇到&lt;code&gt;p&lt;/code&gt;结点则向下；如果两个结点都不是&lt;code&gt;p&lt;/code&gt;结点且其中一个为&lt;code&gt;f&lt;/code&gt;结点，则加上对应区域的像素数目。&lt;/p&gt;
&lt;p&gt;紫书中的解法是考虑四分树对应的图像。一个学到的地方是（正方形）区域的表示：区域的左上角坐标&lt;code&gt;(x,y)&lt;/code&gt;以及区域的宽度&lt;code&gt;w&lt;/code&gt;。这样，在表示四分区域时非常方便。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="入门" scheme="http://lvzhh.github.io/categories/%E5%85%A5%E9%97%A8/"/>
    
      <category term="模拟" scheme="http://lvzhh.github.io/categories/%E5%85%A5%E9%97%A8/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4027 Can you answer these queries?</title>
    <link href="http://lvzhh.github.io/2018/06/HDU-4027-Can-you-answer-these-queries/"/>
    <id>http://lvzhh.github.io/2018/06/HDU-4027-Can-you-answer-these-queries/</id>
    <published>2018-06-08T03:54:53.000Z</published>
    <updated>2018-06-11T00:18:18.881Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给N个数，进行两种操作：1.<code>0 X Y</code>对第X和第Y个数之间的数开根号；2.<code>1 X Y</code>对<br>第X和第Y个数之间的数求和。</p><p>开根号操作需要对区间内的每个数进行，才能使得区间的和得到更新。<br>没有想到的地方在于，<span class="math inline">\(2^{64}\)</span>恰好需要开7次根号变为1，一个小于<span class="math inline">\(2^{63}\)</span>的数最多开6次根号会变为1（如果最初的数&gt;0)，之后再开根号数值不会变化。</p><p>因此，可以得到的解法是，更新操作更新到叶结点，并记录线段树结点开根号的次数，如果次数&gt;=6，则不再向下更新。也就是说，开始的时候每次更新都会更新到叶结点，复杂度为<span class="math inline">\(O(n)\)</span>，对整个区间更新6次后，复杂度变为<span class="math inline">\(O(logn)\)</span>.interesting…<br><a id="more"></a><br>坑：1.输入的Ei要用long long存，看题目描述<code>integers Ei</code>，默认就用了int…<br>2.<code>T X Y</code>操作，X可能大于Y，题目描述的是<code>between X-th and Y-th</code><span class="github-emoji" title="smile" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SQRT = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">ll E[MAX_N];</span><br><span class="line">ll dat[ST_SIZE];</span><br><span class="line"><span class="keyword">int</span> tag[ST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    dat[k] = E[l];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    build(lc, l, m);</span><br><span class="line">    build(rc, m, r);</span><br><span class="line">    dat[k] = dat[lc] + dat[rc];</span><br><span class="line">  &#125;</span><br><span class="line">  tag[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// don't go down</span></span><br><span class="line">    <span class="keyword">if</span> (tag[k] &gt;= MAX_SQRT) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) tag[k]++;</span><br><span class="line">    <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">      dat[k] = (ll) <span class="built_in">sqrt</span>(dat[k]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// go down</span></span><br><span class="line">      <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">      update(lc, l, m, a, b);</span><br><span class="line">      update(rc, m, r, a, b);</span><br><span class="line">      dat[k] = dat[lc] + dat[rc];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">    <span class="keyword">return</span> dat[k];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> query(lc, l, m, a, b) + query(rc, m, r, a, b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N) != EOF) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, c++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, E + i);</span><br><span class="line">    build(<span class="number">0</span>, <span class="number">0</span>, N);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> T, X, Y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;T, &amp;X, &amp;Y);</span><br><span class="line">      <span class="keyword">if</span> (X &gt; Y) swap(X, Y);</span><br><span class="line">      <span class="keyword">if</span> (T == <span class="number">0</span>) &#123;</span><br><span class="line">        update(<span class="number">0</span>, <span class="number">0</span>, N, X - <span class="number">1</span>, Y);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">0</span>, <span class="number">0</span>, N, X - <span class="number">1</span>, Y));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给N个数，进行两种操作：1.&lt;code&gt;0 X Y&lt;/code&gt;对第X和第Y个数之间的数开根号；2.&lt;code&gt;1 X Y&lt;/code&gt;对&lt;br&gt;
第X和第Y个数之间的数求和。&lt;/p&gt;
&lt;p&gt;开根号操作需要对区间内的每个数进行，才能使得区间的和得到更新。&lt;br&gt;
没有想到的地方在于，&lt;span class=&quot;math inline&quot;&gt;\(2^{64}\)&lt;/span&gt;恰好需要开7次根号变为1，一个小于&lt;span class=&quot;math inline&quot;&gt;\(2^{63}\)&lt;/span&gt;的数最多开6次根号会变为1（如果最初的数&amp;gt;0)，之后再开根号数值不会变化。&lt;/p&gt;
&lt;p&gt;因此，可以得到的解法是，更新操作更新到叶结点，并记录线段树结点开根号的次数，如果次数&amp;gt;=6，则不再向下更新。也就是说，开始的时候每次更新都会更新到叶结点，复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，对整个区间更新6次后，复杂度变为&lt;span class=&quot;math inline&quot;&gt;\(O(logn)\)&lt;/span&gt;.interesting…&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="HDU" scheme="http://lvzhh.github.io/tags/HDU/"/>
    
      <category term="kuangbin#线段树" scheme="http://lvzhh.github.io/tags/kuangbin-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>刷题总结</title>
    <link href="http://lvzhh.github.io/2018/06/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://lvzhh.github.io/2018/06/刷题总结/</id>
    <published>2018-06-08T03:33:20.000Z</published>
    <updated>2018-06-13T23:58:13.962Z</updated>
    
    <content type="html"><![CDATA[<p>POJ 3253 Huffman树<br>错误：结果超出了int的范围，应该用long long；而且<code>printf(&quot;%lld&quot;,ans)</code>，注意是<code>lld</code><br>POJ 2686 Traveling by Stagecoach（DAG，状压dp）<br>题目大意：m个结点的无向图，每个结点表示一个城市，n张票，经过一条边消耗一张票，每张票有一个数值，经过一条边的时间为边的长度/票的数值。给定起点a，问终点b是否可达，若可达，求最短时间。<br>用搜索来做，在结点v，有k张票，每条边用k张票去试。<strong>这样可以重新建一张有向图，图中结点表示状态，即所在城市+手中余票，边表示原来边的长度/所用票的数值。问题转化为了从起点到终点的最短路问题。</strong>这个有向图呢，是一个DAG，因此可考虑用dp来求最短路，把票的状态压缩成一个整数T，相当于填一张T*m的表。<br>POJ 3734，3233 （dp，矩阵快幂）<br>POJ 2932 平面扫描（line sweep）<br>POJ 2187 Graham凸包，旋转卡壳求凸多边形直径（最远点对）<br>POJ 1741 树的点分治<br>POJ 3264 RMQ问题，sparse table or segment tree<br><a id="more"></a><br>POJ 2217 两个字符串的最长公共部分：拼接之后求出后缀数组SA和高度数组LCP，高度数组中的最大值即为所求结果<br>POJ 3581 后缀数组（仍需再加考虑）<br>POJ 3690 二维字符哈希<br>POJ 1961，2406，3461 KMP<br>LA 3942 枚举+Trie<br>HDU 2222 AC Automaton<br>ZOJ 1015 Maximum Cardinality Search求完美消除序列，弦图的判定（实现上的问题：图的邻接表和邻接矩阵都需要建立？）<br>BZOJ 1006 弦图的色数<br>LeetCode 最长回文串 Manacher‘s Algorithm https://www.felix021.com/blog/read.php?2040<br>POJ 3061，3320 尺取法</p><h4 id="zoj-1610-count-the-colors">ZOJ 1610 Count the Colors</h4><p>线段树，区间更新</p><h4 id="uva-699-the-falling-leaves">UVA 699 The Falling Leaves</h4><p>二叉树构建、遍历。一个想错的地方是，下落后最靠左的结点是根的左孩子的左孩子的左孩子…（直到叶结点）。一个反例是，根的右孩子的左孩子向左延伸很长，成为下落后最靠左的结点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POJ 3253 Huffman树&lt;br&gt;
错误：结果超出了int的范围，应该用long long；而且&lt;code&gt;printf(&amp;quot;%lld&amp;quot;,ans)&lt;/code&gt;，注意是&lt;code&gt;lld&lt;/code&gt;&lt;br&gt;
POJ 2686 Traveling by Stagecoach（DAG，状压dp）&lt;br&gt;
题目大意：m个结点的无向图，每个结点表示一个城市，n张票，经过一条边消耗一张票，每张票有一个数值，经过一条边的时间为边的长度/票的数值。给定起点a，问终点b是否可达，若可达，求最短时间。&lt;br&gt;
用搜索来做，在结点v，有k张票，每条边用k张票去试。&lt;strong&gt;这样可以重新建一张有向图，图中结点表示状态，即所在城市+手中余票，边表示原来边的长度/所用票的数值。问题转化为了从起点到终点的最短路问题。&lt;/strong&gt;这个有向图呢，是一个DAG，因此可考虑用dp来求最短路，把票的状态压缩成一个整数T，相当于填一张T*m的表。&lt;br&gt;
POJ 3734，3233 （dp，矩阵快幂）&lt;br&gt;
POJ 2932 平面扫描（line sweep）&lt;br&gt;
POJ 2187 Graham凸包，旋转卡壳求凸多边形直径（最远点对）&lt;br&gt;
POJ 1741 树的点分治&lt;br&gt;
POJ 3264 RMQ问题，sparse table or segment tree&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://lvzhh.github.io/categories/Notes/"/>
    
    
      <category term="刷题总结" scheme="http://lvzhh.github.io/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>HDU 3974 Assign the task</title>
    <link href="http://lvzhh.github.io/2018/06/HDU-3974-Assign-the-task/"/>
    <id>http://lvzhh.github.io/2018/06/HDU-3974-Assign-the-task/</id>
    <published>2018-06-08T02:16:10.000Z</published>
    <updated>2018-06-08T04:36:42.371Z</updated>
    
    <content type="html"><![CDATA[<p>dfs序可以把结点v及其子树放在连续的区间中<br>分配任务操作<code>T x y</code>相当于把一个连续的区间置为y，可以用线段树来维护<br>查询操作为线段树的单点查询<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> leader[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vs;</span><br><span class="line"><span class="keyword">int</span> id[MAX_N];</span><br><span class="line"><span class="keyword">int</span> size[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= N; v++) &#123;</span><br><span class="line">    G[v].clear();</span><br><span class="line">    leader[v] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vs.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  id[v] = vs.size();</span><br><span class="line">  vs.push_back(v);</span><br><span class="line">  size[v] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = G[v][i];</span><br><span class="line">    dfs(u);</span><br><span class="line">    size[v] += size[u];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (2 * k + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (2 * k + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m ((l + r) / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> task[ST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(task, <span class="number">-1</span>, <span class="keyword">sizeof</span>(task));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task[k] != <span class="number">-1</span>) &#123;</span><br><span class="line">    task[lc] = task[rc] = task[k];</span><br><span class="line">    task[k] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">    task[k] = x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    push_down(k);</span><br><span class="line">    update(lc, l, m, a, b, x);</span><br><span class="line">    update(rc, m, r, a, b, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> task[k];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    push_down(k);</span><br><span class="line">    <span class="keyword">if</span> (a &lt; m) <span class="keyword">return</span> query(lc, l, m, a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rc, m, r, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= T; t++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, t);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">      G[v].push_back(u);</span><br><span class="line">      leader[u] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= N; v++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (leader[v]) root = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root);</span><br><span class="line">    build();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> cmd;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;cmd);</span><br><span class="line">      <span class="keyword">if</span> (cmd == <span class="string">'C'</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">0</span>, <span class="number">0</span>, N, id[x]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        update(<span class="number">0</span>, <span class="number">0</span>, N, id[x], id[x] + size[x], y);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dfs序可以把结点v及其子树放在连续的区间中&lt;br&gt;
分配任务操作&lt;code&gt;T x y&lt;/code&gt;相当于把一个连续的区间置为y，可以用线段树来维护&lt;br&gt;
查询操作为线段树的单点查询&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="搜索" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="线段树" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="dfs序" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/dfs%E5%BA%8F/"/>
    
    
      <category term="HDU" scheme="http://lvzhh.github.io/tags/HDU/"/>
    
      <category term="kuangbin#线段树" scheme="http://lvzhh.github.io/tags/kuangbin-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1540 Tunnel Warfare</title>
    <link href="http://lvzhh.github.io/2018/06/HDU-1540-Tunnel-Warfare/"/>
    <id>http://lvzhh.github.io/2018/06/HDU-1540-Tunnel-Warfare/</id>
    <published>2018-06-07T17:00:25.000Z</published>
    <updated>2018-06-08T02:14:16.712Z</updated>
    
    <content type="html"><![CDATA[<p>题意：一个0\1序列，初始为全1，会把某个点从0变1，或从1变为0，求包含x的最长全1序列长度。</p><p>开始想到的解法是：求包含x的最长全1序列长度，那么从x向左找到第一个0的位置，从x向右找到第一个0，这中间的即为所求序列。因此，线段树的每个结点需要维护的信息为<code>mi[k],mx[k]</code>，即最左0和最右0的位置。每次查询时求出[1,x+1)区间中最右的0和[x+1,n+1)区间中最左的0的位置，两者之间元素的数目即为所求长度。<br><a id="more"></a><br>后面看到<a href="http://www.cnblogs.com/kuangbin/archive/2012/08/15/2640857.html" target="_blank" rel="noopener">这篇博客</a>中用线段树维护三个区间长度信息来做。</p><p>坑：虽然题目没说有多个case，但是需要处理到EOF啊 <span class="github-emoji" title="smile" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><p>第一种解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">// leftmost and rightmost destroyed village</span></span><br><span class="line"><span class="keyword">int</span> mi[ST_SIZE], mx[ST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">  mi[k] = min(mi[lc], mi[rc]);</span><br><span class="line">  mx[k] = max(mx[lc], mx[rc]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    mi[k] = n + <span class="number">1</span>;</span><br><span class="line">    mx[k] = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    build(lc, l, m);</span><br><span class="line">    build(rc, m, r);</span><br><span class="line">    push_up(k, lc, rc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; l || r &lt;= x) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    mi[k] = x;</span><br><span class="line">    mx[k] = x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    destroy(lc, l, m, x);</span><br><span class="line">    destroy(rc, m, r, x);</span><br><span class="line">    push_up(k, lc, rc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; l || r &lt;= x) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    mi[k] = n + <span class="number">1</span>;</span><br><span class="line">    mx[k] = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    restore(lc, l, m, x);</span><br><span class="line">    restore(rc, m, r, x);</span><br><span class="line">    push_up(k, lc, rc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Pair <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span> Pair(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Pair(mi[k], mx[k]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    Pair p1 = query(lc, l, m, a, b);</span><br><span class="line">    Pair p2 = query(rc, m, r, a, b);</span><br><span class="line">    <span class="keyword">return</span> Pair(min(p1.first, p2.first), max(p1.second, p2.second));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d  %d"</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">    build(<span class="number">0</span>, <span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> event;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;event);</span><br><span class="line">      <span class="keyword">if</span> (event == <span class="string">'R'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.empty()) <span class="keyword">continue</span>;</span><br><span class="line">        x = stk.top(); stk.pop();</span><br><span class="line">        restore(<span class="number">0</span>, <span class="number">1</span>, n + <span class="number">1</span>, x);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="string">'D'</span>) &#123;</span><br><span class="line">          <span class="comment">// destory destroyed village ?</span></span><br><span class="line">          stk.push(x);</span><br><span class="line">          destroy(<span class="number">0</span>, <span class="number">1</span>, n + <span class="number">1</span>, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Pair p1 = query(<span class="number">0</span>, <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">1</span>, x + <span class="number">1</span>);</span><br><span class="line">          Pair p2 = query(<span class="number">0</span>, <span class="number">1</span>, n + <span class="number">1</span>, x, n + <span class="number">1</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(<span class="number">0</span>, p2.first - (p1.second + <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (2 * k + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (2 * k + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m ((l + r) / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> ls[ST_SIZE], rs[ST_SIZE], ms[ST_SIZE]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ls[k] = ls[lc] == m - l ? ls[lc] + ls[rc] : ls[lc];</span><br><span class="line">  rs[k] = rs[rc] == r - m ? rs[rc] + rs[lc] : rs[rc];</span><br><span class="line">  ms[k] = max(rs[lc] + ls[rc], max(ms[lc], ms[rc]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    ls[k] = rs[k] = ms[k] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    build(lc, l, m);</span><br><span class="line">    build(rc, m, r);</span><br><span class="line">    push_up(k, l, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    ls[k] = rs[k] = ms[k] = x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update(lc, l, m, a, x);</span><br><span class="line">    update(rc, m, r, a, x);</span><br><span class="line">    push_up(k, l, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ms[k];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> res = max(query(lc, l, m, a), query(rc, m, r, a));</span><br><span class="line">    <span class="keyword">if</span> (m - rs[lc] &lt;= a &amp;&amp; a &lt; m + ls[rc]) &#123;</span><br><span class="line">      res = max(res, rs[lc] + ls[rc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d  %d"</span>, &amp;N, &amp;M) != EOF) &#123;</span><br><span class="line">    build(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> event;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;event);</span><br><span class="line">      <span class="keyword">if</span> (event == <span class="string">'R'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.empty()) <span class="keyword">continue</span>;</span><br><span class="line">        x = stk.top(); stk.pop();</span><br><span class="line">        update(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>, x, <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="string">'D'</span>) &#123;</span><br><span class="line">          <span class="comment">// destory destroyed village ?</span></span><br><span class="line">          stk.push(x);</span><br><span class="line">          update(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>, x, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>, x));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：一个0\1序列，初始为全1，会把某个点从0变1，或从1变为0，求包含x的最长全1序列长度。&lt;/p&gt;
&lt;p&gt;开始想到的解法是：求包含x的最长全1序列长度，那么从x向左找到第一个0的位置，从x向右找到第一个0，这中间的即为所求序列。因此，线段树的每个结点需要维护的信息为&lt;code&gt;mi[k],mx[k]&lt;/code&gt;，即最左0和最右0的位置。每次查询时求出[1,x+1)区间中最右的0和[x+1,n+1)区间中最左的0的位置，两者之间元素的数目即为所求长度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="HDU" scheme="http://lvzhh.github.io/tags/HDU/"/>
    
      <category term="kuangbin#线段树" scheme="http://lvzhh.github.io/tags/kuangbin-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3667 Hotel</title>
    <link href="http://lvzhh.github.io/2018/06/POJ-3667-Hotel/"/>
    <id>http://lvzhh.github.io/2018/06/POJ-3667-Hotel/</id>
    <published>2018-06-07T16:56:59.000Z</published>
    <updated>2018-06-08T01:32:38.952Z</updated>
    
    <content type="html"><![CDATA[<p>题意：排成一行的旅馆房间<br>checkin时找到最靠左的空闲的长度&gt;=d的连续区间，输出区间的左端点<span class="math inline">\(r\)</span>并入住<br>checkout时把从x开始的长度为d的区间变为空闲</p><p>线段树的区间合并问题？<br>空闲0\1表示，区间置0\1可以用打标记来实现。<br>如何找到满足条件的区间端点<span class="math inline">\(r\)</span>呢？线段树每个结点维护的信息为从区间左端点开始的全0序列的长度ls，从区间右端点开始的全0序列的长度rs，区间中最长的全0序列长度ms。如果线段树某个结点ms&gt;=d，那么最长的区间可以来入住，最长区间有三种情况：完全在左儿子的区间，横跨左右儿子的区间，完全在右儿子的区间。因为<span class="math inline">\(r\)</span>要满足最靠左，所以依次尝试上面三种可能情况。<br><a id="more"></a><br>注意在查询的时候下传标记。由于query函数写法的原因，如果某个区间被置为全0\1，那么这个区间一定满足<code>ms[k] == ls[k]</code>，因此一定满足<code>ms[k] &lt; d</code>、<code>ls[k] &gt;= d</code>其中之一而退出。如果继续向下执行，那么结点k一定是没有标记的，不需要向下传标记。这也是为什么第一次交的时候没有<code>push_down</code>也过了。</p><p>有了宏定义后代码精简了好多…<br>刚开始接触这类区间问题，还比较生疏…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (2 * k + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (2 * k + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m ((l + r) / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> ls[ST_SIZE], rs[ST_SIZE], ms[ST_SIZE], check[ST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_tag</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    ls[k] = rs[k] = ms[k] = r - l;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ls[k] = rs[k] = ms[k] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  check[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  ls[k] = ls[lc] == m - l ? ls[lc] + ls[rc] : ls[lc];</span><br><span class="line">  rs[k] = rs[rc] == r - m ? rs[rc] + rs[lc] : rs[rc];</span><br><span class="line">  ms[k] = max(max(ms[lc], ms[rc]), rs[lc] + ls[rc]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (check[k] != <span class="number">-1</span>) &#123;</span><br><span class="line">    set_tag(lc, l, m, check[k]);</span><br><span class="line">    set_tag(rc, m, r, check[k]);</span><br><span class="line">    check[k] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    ls[k] = rs[k] = ms[k] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    build(lc, l, m);</span><br><span class="line">    build(rc, m, r);</span><br><span class="line">    push_up(k, l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  check[k] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">    set_tag(k, l, r, x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    push_down(k, l, r);</span><br><span class="line">    update(lc, l, m, a, b, x);</span><br><span class="line">    update(rc, m, r, a, b, x);</span><br><span class="line">    push_up(k, l, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ms[k] &lt; d) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ls[k] &gt;= d) <span class="keyword">return</span> l;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// if go down, then there is no tag on k</span></span><br><span class="line">    push_down(k, l, r);</span><br><span class="line">    <span class="keyword">if</span> (ms[lc] &gt;= d) <span class="keyword">return</span> query(lc, l, m, d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rs[lc] + ls[rc] &gt;= d) <span class="keyword">return</span> m - rs[lc];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rc, m, r, d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">  build(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (M--) &#123;</span><br><span class="line">    <span class="keyword">int</span> req, d, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;req);</span><br><span class="line">    <span class="keyword">if</span> (req == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">      <span class="keyword">int</span> res = query(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>, d);</span><br><span class="line">      <span class="keyword">if</span> (res) update(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>, res, res + d, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;d);</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">1</span>, N + <span class="number">1</span>, x, x + d, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：排成一行的旅馆房间&lt;br&gt;
checkin时找到最靠左的空闲的长度&amp;gt;=d的连续区间，输出区间的左端点&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;并入住&lt;br&gt;
checkout时把从x开始的长度为d的区间变为空闲&lt;/p&gt;
&lt;p&gt;线段树的区间合并问题？&lt;br&gt;
空闲0\1表示，区间置0\1可以用打标记来实现。&lt;br&gt;
如何找到满足条件的区间端点&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;呢？线段树每个结点维护的信息为从区间左端点开始的全0序列的长度ls，从区间右端点开始的全0序列的长度rs，区间中最长的全0序列长度ms。如果线段树某个结点ms&amp;gt;=d，那么最长的区间可以来入住，最长区间有三种情况：完全在左儿子的区间，横跨左右儿子的区间，完全在右儿子的区间。因为&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;要满足最靠左，所以依次尝试上面三种可能情况。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="POJ" scheme="http://lvzhh.github.io/tags/POJ/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2528 Mayor&#39;s posters</title>
    <link href="http://lvzhh.github.io/2018/06/POJ-2528-Mayor-s-posters/"/>
    <id>http://lvzhh.github.io/2018/06/POJ-2528-Mayor-s-posters/</id>
    <published>2018-06-07T16:55:03.000Z</published>
    <updated>2018-06-08T09:56:44.481Z</updated>
    
    <content type="html"><![CDATA[<p>每张海报的坐标范围<span class="math inline">\(0&lt;=l_i&lt;=r_i&lt;=10^7\)</span>，线段树维护<span class="math inline">\(10^7\)</span>长度的序列会爆内存。但是海报的数量<span class="math inline">\(1 &lt;= n &lt;= 10000\)</span>，也就是线段树需要更新的区间端点数&lt;=20000个，因此对坐标进行离散化处理。</p><p><a href="https://blog.csdn.net/Chrome_matrix_68/article/details/52154139" target="_blank" rel="noopener">这篇博客</a>中指出普通的离散化在这个题中有些问题，考虑下面这组数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 10</span><br><span class="line">1 4</span><br><span class="line">6 10</span><br></pre></td></tr></table></figure></p><p>离散化坐标映射后，1-&gt;0，4-&gt;1，6-&gt;2，10-&gt;3，更新完后，区间[0,1],[2,3]被后面两张海报覆盖，可见的海报数为2。而第一张海报在原始区间[5,5]仍然可见，答案应为3.</p><p>因此，如果排序后相邻两坐标<span class="math inline">\(x_i,x_{i+1}\)</span>的差&gt;1，则需要在两者之间插入一个数，使得离散后<span class="math inline">\(x_i,x_{i+1}\)</span>的差也&gt;1。区间<span class="math inline">\((x_i,x_{i+1})\)</span>中可见的海报数为0或1，仅需要插入一个数，其信息在最终就能够被统计到。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">17</span>; <span class="comment">// 40000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> L[MAX_N], R[MAX_N];</span><br><span class="line"><span class="keyword">int</span> change[ST_SIZE];</span><br><span class="line"><span class="keyword">bool</span> visible[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(change, <span class="number">0</span>, <span class="keyword">sizeof</span>(change));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">    change[k] = c;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (change[k]) &#123;</span><br><span class="line">      change[lc] = change[k];</span><br><span class="line">      change[rc] = change[k];</span><br><span class="line">      change[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(lc, l, m, a, b, c);</span><br><span class="line">    update(rc, m, r, a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (change[k]) visible[change[k]] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (change[k]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      query(<span class="number">2</span> * k + <span class="number">1</span>, l, (l + r) / <span class="number">2</span>);</span><br><span class="line">      query(<span class="number">2</span> * k + <span class="number">2</span>, (l + r) / <span class="number">2</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, L + i, R + i);</span><br><span class="line">      p.push_back(L[i]);</span><br><span class="line">      p.push_back(R[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p.begin(), p.end());</span><br><span class="line">    p.erase(unique(p.begin(), p.end()), p.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[i] != p[i - <span class="number">1</span>] + <span class="number">1</span>) p.push_back(p[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p.begin(), p.end());</span><br><span class="line"></span><br><span class="line">    init(<span class="number">0</span>, <span class="number">0</span>, p.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> l = lower_bound(p.begin(), p.end(), L[i]) - p.begin();</span><br><span class="line">      <span class="keyword">int</span> r = lower_bound(p.begin(), p.end(), R[i]) - p.begin();</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, p.size(), l, r + <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visible, <span class="number">0</span>, <span class="keyword">sizeof</span>(visible));</span><br><span class="line">    query(<span class="number">0</span>, <span class="number">0</span>, p.size());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (visible[i]) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每张海报的坐标范围&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;=l_i&amp;lt;=r_i&amp;lt;=10^7\)&lt;/span&gt;，线段树维护&lt;span class=&quot;math inline&quot;&gt;\(10^7\)&lt;/span&gt;长度的序列会爆内存。但是海报的数量&lt;span class=&quot;math inline&quot;&gt;\(1 &amp;lt;= n &amp;lt;= 10000\)&lt;/span&gt;，也就是线段树需要更新的区间端点数&amp;lt;=20000个，因此对坐标进行离散化处理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Chrome_matrix_68/article/details/52154139&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇博客&lt;/a&gt;中指出普通的离散化在这个题中有些问题，考虑下面这组数据&lt;br&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6 10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;离散化坐标映射后，1-&amp;gt;0，4-&amp;gt;1，6-&amp;gt;2，10-&amp;gt;3，更新完后，区间[0,1],[2,3]被后面两张海报覆盖，可见的海报数为2。而第一张海报在原始区间[5,5]仍然可见，答案应为3.&lt;/p&gt;
&lt;p&gt;因此，如果排序后相邻两坐标&lt;span class=&quot;math inline&quot;&gt;\(x_i,x_{i+1}\)&lt;/span&gt;的差&amp;gt;1，则需要在两者之间插入一个数，使得离散后&lt;span class=&quot;math inline&quot;&gt;\(x_i,x_{i+1}\)&lt;/span&gt;的差也&amp;gt;1。区间&lt;span class=&quot;math inline&quot;&gt;\((x_i,x_{i+1})\)&lt;/span&gt;中可见的海报数为0或1，仅需要插入一个数，其信息在最终就能够被统计到。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="kuangbin#线段树" scheme="http://lvzhh.github.io/tags/kuangbin-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="POJ" scheme="http://lvzhh.github.io/tags/POJ/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3225 Help with Intervals</title>
    <link href="http://lvzhh.github.io/2018/06/POJ-3225-Help-with-Intervals/"/>
    <id>http://lvzhh.github.io/2018/06/POJ-3225-Help-with-Intervals/</id>
    <published>2018-06-06T15:36:40.000Z</published>
    <updated>2018-06-08T05:54:57.932Z</updated>
    
    <content type="html"><![CDATA[<p>题意：完成5种集合操作，输出最终的集合。</p><p>若把集合<code>S</code>用0\1序列来表示，则集合操作可转化为对连续子序列（区间）的操作。</p><p><span class="math inline">\(T^C\)</span>表示<span class="math inline">\(T\)</span>的补集</p><table><tbody><tr class="odd"><td><span class="math inline">\(S \cup T\)</span></td><td><span class="math inline">\(T\)</span>区间置1</td></tr><tr class="even"><td><span class="math inline">\(S \cap T\)</span></td><td><span class="math inline">\(T^C\)</span>区间置0</td></tr><tr class="odd"><td><span class="math inline">\(S - T\)</span></td><td><span class="math inline">\(T\)</span>区间置0</td></tr><tr class="even"><td><span class="math inline">\(T - S\)</span></td><td><span class="math inline">\(S\)</span>取反，<span class="math inline">\(T^C\)</span>区间置0</td></tr><tr class="odd"><td><span class="math inline">\(S \oplus T\)</span></td><td><span class="math inline">\(T\)</span>区间取反</td></tr></tbody></table><p>区间操作有两种，置0\1和取反。置0\1可以用线段树打lazy tag来实现，取反也可以用打标记来实现。这里只用了一个标记，标记的种类有无标记、0、1、取反四种，打0\1标记时不需要考虑之前标记的类型，打取反标记时，若之前为0\1，则标记变为1\0，若之前为取反，则变为无标记，若之前为无标记，则变为取反标记。</p><p>最后，在完成所有操作后，下传所有标记。<br><a id="more"></a><br>开区间、闭区间的处理：把集合序列扩充为原来的3倍，对于数a：</p><table><tbody><tr class="odd"><td><span class="math inline">\(3a\)</span></td><td><code>)</code></td></tr><tr class="even"><td><span class="math inline">\(3a+1\)</span></td><td><code>]</code>or<code>[</code></td></tr><tr class="odd"><td><span class="math inline">\(3a+2\)</span></td><td><code>(</code></td></tr></tbody></table><p>这样，<code>(a,b)</code>包含在<code>[a,b]</code>中，集合取补操作也比较直观。</p><p><a href="http://www.cnblogs.com/kuangbin/archive/2013/04/10/3012986.html" target="_blank" rel="noopener">这篇博客</a>对开闭区间的处理为扩充序列为原来的2倍，对于数a：</p><table><tbody><tr class="odd"><td><span class="math inline">\(2a-1\)</span></td><td><code>)</code></td></tr><tr class="even"><td><span class="math inline">\(2a\)</span></td><td><code>]</code>or<code>[</code></td></tr><tr class="odd"><td><span class="math inline">\(2a+1\)</span></td><td><code>(</code></td></tr></tbody></table><p><span class="math inline">\(2a-1\)</span>既表示<code>a)</code>，也表示<code>(a-1</code>。</p><p>坑：第一次见用开闭区间表示实数集合，开始还以为区间表示的是整数集合，看着样例输出<code>(2,3)</code>一脸懵…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = (<span class="number">65535</span> + <span class="number">1</span>) * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S[M];</span><br><span class="line"><span class="keyword">int</span> tag[ST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M &amp;&amp; S[i] == <span class="number">0</span>; i++);</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= M) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"empty set\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; M) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = i; j + <span class="number">1</span> &lt; M &amp;&amp; S[j + <span class="number">1</span>] == <span class="number">1</span>; j++);</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%d,%d%c"</span>, i % <span class="number">3</span> == <span class="number">2</span> ? <span class="string">'('</span> : <span class="string">'['</span>, i / <span class="number">3</span>, j / <span class="number">3</span>, j % <span class="number">3</span> == <span class="number">0</span> ? <span class="string">')'</span> : <span class="string">']'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c%d,%d%c"</span>, i % <span class="number">3</span> == <span class="number">2</span> ? <span class="string">'('</span> : <span class="string">'['</span>, i / <span class="number">3</span>, j / <span class="number">3</span>, j % <span class="number">3</span> == <span class="number">0</span> ? <span class="string">')'</span> : <span class="string">']'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (i = j + <span class="number">1</span>; i &lt; M &amp;&amp; S[i] == <span class="number">0</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_tag</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">    tag[k] = x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[k] == <span class="number">-1</span>) tag[k] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tag[k] == <span class="number">0</span> || tag[k] == <span class="number">1</span>) tag[k] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tag[k] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tag[k] != <span class="number">-1</span>) &#123;</span><br><span class="line">    set_tag(lc, tag[k]);</span><br><span class="line">    set_tag(rc, tag[k]);</span><br><span class="line">    tag[k] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">    set_tag(k, x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    push_down(k, lc, rc);</span><br><span class="line">    update(lc, l, m, a, b, x);</span><br><span class="line">    update(rc, m, r, a, b, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[k] == <span class="number">0</span> || tag[k] == <span class="number">-1</span>) &#123;</span><br><span class="line">      S[l] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      S[l] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">2</span> * k + <span class="number">1</span>, rc = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    push_down(k, lc, rc);</span><br><span class="line">    down(lc, l, m);</span><br><span class="line">    down(rc, m, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(S, <span class="number">0</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">  <span class="built_in">memset</span>(tag, <span class="number">-1</span>, <span class="keyword">sizeof</span>(tag));</span><br><span class="line">  <span class="keyword">char</span> X, lb, rb;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">" %c %c%d%*c%d %c"</span>, &amp;X, &amp;lb, &amp;a, &amp;b, &amp;rb) != EOF) &#123;</span><br><span class="line">    a = lb == <span class="string">'('</span> ? <span class="number">3</span> * a + <span class="number">2</span> : <span class="number">3</span> * a + <span class="number">1</span>;</span><br><span class="line">    b = rb == <span class="string">')'</span> ? <span class="number">3</span> * b : <span class="number">3</span> * b + <span class="number">1</span>;</span><br><span class="line">    b++; <span class="comment">// [a, b)</span></span><br><span class="line">    <span class="keyword">if</span> (X == <span class="string">'U'</span>) &#123;</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, a, b, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//      for (int i = a; i &lt; b; i++) </span></span><br><span class="line"><span class="comment">//        S[i] = 1;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (X == <span class="string">'I'</span>) &#123;</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, <span class="number">0</span>, a, <span class="number">0</span>);</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, b, M, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//      for (int i = 0; i &lt; a; i++) </span></span><br><span class="line"><span class="comment">//        S[i] = 0;</span></span><br><span class="line"><span class="comment">//      for (int i = b; i &lt; M; i++) </span></span><br><span class="line"><span class="comment">//        S[i] = 0;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (X == <span class="string">'D'</span>) &#123;</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, a, b, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//      for (int i = a; i &lt; b; i++)</span></span><br><span class="line"><span class="comment">//        S[i] = 0;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (X == <span class="string">'C'</span>) &#123;</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, <span class="number">0</span>, M, <span class="number">2</span>);</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, <span class="number">0</span>, a, <span class="number">0</span>);</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, b, M, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//      for (int i = 0; i &lt; M; i++)</span></span><br><span class="line"><span class="comment">//        S[i] ^= 1;</span></span><br><span class="line"><span class="comment">//      for (int i = 0; i &lt; a; i++) </span></span><br><span class="line"><span class="comment">//        S[i] = 0;</span></span><br><span class="line"><span class="comment">//      for (int i = b; i &lt; M; i++) </span></span><br><span class="line"><span class="comment">//        S[i] = 0;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      update(<span class="number">0</span>, <span class="number">0</span>, M, a, b, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//      for (int i = a; i &lt; b; i++)</span></span><br><span class="line"><span class="comment">//        S[i] ^= 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  down(<span class="number">0</span>, <span class="number">0</span>, M);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M &amp;&amp; S[i] == <span class="number">0</span>; i++);</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= M) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"empty set\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; M) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = i; j + <span class="number">1</span> &lt; M &amp;&amp; S[j + <span class="number">1</span>] == <span class="number">1</span>; j++);</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%d,%d%c"</span>, i % <span class="number">3</span> == <span class="number">2</span> ? <span class="string">'('</span> : <span class="string">'['</span>, i / <span class="number">3</span>, j / <span class="number">3</span>, j % <span class="number">3</span> == <span class="number">0</span> ? <span class="string">')'</span> : <span class="string">']'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c%d,%d%c"</span>, i % <span class="number">3</span> == <span class="number">2</span> ? <span class="string">'('</span> : <span class="string">'['</span>, i / <span class="number">3</span>, j / <span class="number">3</span>, j % <span class="number">3</span> == <span class="number">0</span> ? <span class="string">')'</span> : <span class="string">']'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (i = j + <span class="number">1</span>; i &lt; M &amp;&amp; S[i] == <span class="number">0</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：完成5种集合操作，输出最终的集合。&lt;/p&gt;
&lt;p&gt;若把集合&lt;code&gt;S&lt;/code&gt;用0\1序列来表示，则集合操作可转化为对连续子序列（区间）的操作。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(T^C\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;的补集&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(S \cup T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;区间置1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(S \cap T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(T^C\)&lt;/span&gt;区间置0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(S - T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;区间置0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(T - S\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;取反，&lt;span class=&quot;math inline&quot;&gt;\(T^C\)&lt;/span&gt;区间置0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(S \oplus T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;区间取反&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;区间操作有两种，置0\1和取反。置0\1可以用线段树打lazy tag来实现，取反也可以用打标记来实现。这里只用了一个标记，标记的种类有无标记、0、1、取反四种，打0\1标记时不需要考虑之前标记的类型，打取反标记时，若之前为0\1，则标记变为1\0，若之前为取反，则变为无标记，若之前为无标记，则变为取反标记。&lt;/p&gt;
&lt;p&gt;最后，在完成所有操作后，下传所有标记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="POJ" scheme="http://lvzhh.github.io/tags/POJ/"/>
    
  </entry>
  
  <entry>
    <title>UVA 816 Abbott&#39;s Revenge</title>
    <link href="http://lvzhh.github.io/2018/06/UVA-816-Abbott-s-Revenge/"/>
    <id>http://lvzhh.github.io/2018/06/UVA-816-Abbott-s-Revenge/</id>
    <published>2018-06-06T15:18:39.000Z</published>
    <updated>2018-06-06T15:59:59.585Z</updated>
    
    <content type="html"><![CDATA[<p>题意：迷宫中的点从不同方向进入时有不同的转向，求起点到终点的最短路。</p><p>每个点除了坐标x，y外，还有方向属性d。用BFS求最短路，存储BFS树中结点的父结点用于路径还原。</p><p>学习了一种用<code>strchr</code>来得到字符id的写法。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">9</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sx, sy, tx, ty;</span><br><span class="line"><span class="built_in">string</span> sd;</span><br><span class="line"><span class="keyword">int</span> maze[MAX_N][MAX_N][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Pair&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dX[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dY[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">int</span> x, y, d; &#125;;</span><br><span class="line">Point pre[MAX_N][MAX_N][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* dir = <span class="string">"SWNE"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* adir = <span class="string">"LFR"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">did</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">strchr</span>(dir, c) - dir; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adid</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">strchr</span>(adir, c) - adir; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;Point&gt; que;</span><br><span class="line">  <span class="keyword">int</span> x, y, d, fd = did(sd[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">int</span> nx = sx + dX[fd], ny = sy + dY[fd];</span><br><span class="line">  pre[nx][ny][fd] = (Point) &#123;sx, sy, fd&#125;;</span><br><span class="line">  que.push((Point) &#123;nx, ny, fd&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    Point p = que.front(); que.pop();</span><br><span class="line">    x = p.x, y = p.y, d = p.d;</span><br><span class="line">    <span class="keyword">if</span> (x == tx &amp;&amp; y == ty) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!((maze[x][y][d] &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      fd = d;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) fd = (fd - <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) fd = (fd + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> nx = x + dX[fd], ny = y + dY[fd];</span><br><span class="line">      Point&amp; pp = pre[nx][ny][fd];</span><br><span class="line">      <span class="keyword">if</span> (pp.x == <span class="number">0</span> &amp;&amp; pp.y == <span class="number">0</span> &amp;&amp; pp.d == <span class="number">0</span>) &#123;</span><br><span class="line">        pp = (Point) &#123;x, y, d&#125;;</span><br><span class="line">        que.push((Point) &#123;nx, ny, fd&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    Point pp = pre[tx][ty][i];</span><br><span class="line">    <span class="keyword">if</span> (pp.x == <span class="number">0</span> &amp;&amp; pp.y == <span class="number">0</span> &amp;&amp; pp.d == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    Point p = (Point) &#123;tx, ty, i&#125;;</span><br><span class="line">    <span class="keyword">while</span> (p.x != sx || p.y != sy) &#123;</span><br><span class="line">      ans.push_back(Pair(p.x, p.y));</span><br><span class="line">      p = pre[p.x][p.y][p.d];</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(Pair(sx, sy));</span><br><span class="line">    reverse(ans.begin(), ans.end());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name, ad;</span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; name &amp;&amp; name != <span class="string">"END"</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(maze, <span class="number">0</span>, <span class="keyword">sizeof</span>(maze));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    ans.clear();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; sd &gt;&gt; tx &gt;&gt; ty;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x &amp;&amp; x) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ad &amp;&amp; ad != <span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ad.size(); i++) &#123;</span><br><span class="line">          maze[x][y][did(ad[<span class="number">0</span>])] |= <span class="number">1</span> &lt;&lt; adid(ad[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> res = bfs();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; ans[i].first &lt;&lt; <span class="string">","</span> &lt;&lt; ans[i].second &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != ans.size() - <span class="number">1</span>)</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"  No Solution Possible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：迷宫中的点从不同方向进入时有不同的转向，求起点到终点的最短路。&lt;/p&gt;
&lt;p&gt;每个点除了坐标x，y外，还有方向属性d。用BFS求最短路，存储BFS树中结点的父结点用于路径还原。&lt;/p&gt;
&lt;p&gt;学习了一种用&lt;code&gt;strchr&lt;/code&gt;来得到字符id的写法。&lt;/p&gt;
    
    </summary>
    
      <category term="搜索" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="BFS" scheme="http://lvzhh.github.io/categories/%E6%90%9C%E7%B4%A2/BFS/"/>
    
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
  </entry>
  
  <entry>
    <title>memo</title>
    <link href="http://lvzhh.github.io/2018/05/memo/"/>
    <id>http://lvzhh.github.io/2018/05/memo/</id>
    <published>2018-05-27T10:03:03.000Z</published>
    <updated>2018-06-18T03:32:39.853Z</updated>
    
    <content type="html"><![CDATA[<ol type="1"><li>输入输出<br>printf会把float隐式转换为double，所以两者的specifier都可以是<code>'%f'</code></li></ol><table><thead><tr class="header"><th>function</th><th style="text-align: center;">int</th><th style="text-align: right;">long long</th></tr></thead><tbody><tr class="odd"><td><code>scanf</code></td><td style="text-align: center;"><code>'%d'</code></td><td style="text-align: right;"><code>'%lld'</code></td></tr><tr class="even"><td><code>printf</code></td><td style="text-align: center;"><code>'%d'</code></td><td style="text-align: right;"><code>'%lld'</code></td></tr></tbody></table><p>read a single character ignoring whitespace<br><code>scanf(&quot; %c&quot;, &amp;c)</code> place a whitespace before <code>%c</code><br><a id="more"></a></p><p>use <code>sscanf</code> to read from a C string<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s); <span class="comment">// "(10,RL)"</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">sscanf</span>(&amp;s[<span class="number">1</span>], <span class="string">"%d"</span>, &amp;n); <span class="comment">// n = 10</span></span><br></pre></td></tr></table></figure></p><p>read a whole line<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(s, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[^\n]%*c"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// no gets</span></span><br><span class="line"><span class="comment">// gets(s);</span></span><br><span class="line"><span class="comment">// fgets stores '\n' into s</span></span><br><span class="line">fgets(s, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p><p>stringstream 清空<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss.str(<span class="string">""</span>); <span class="comment">// clear the content</span></span><br><span class="line">ss.clear(); <span class="comment">// set a new value for stream's internal error state flags</span></span><br></pre></td></tr></table></figure></p><p>from <a href="https://stackoverflow.com/questions/2848087/how-to-clear-stringstream" target="_blank" rel="noopener">stackoverflow</a></p><blockquote><p>Typically to ‘reset’ a stringstream you need to both reset the underlying sequence to an empty string with str and to clear any fail and eof flags with clear.<br>parser.str( std::string() );<br>parser.clear();<br>Typically what happens is that the first &gt;&gt; reaches the end of the string and sets the eof bit, although it successfully parses the first short. Operations on the stream after this immediately fail because the stream’s eof bit is still set.</p></blockquote><ol start="2" type="1"><li><p>bit operation<br>attention! <code>-1 &gt;&gt; 1 =&gt; -1 not 0</code><br>from <a href="http://train.usaco.org/usacotext2?a=apGwTk9Q5Nt&amp;S=binary" target="_blank" rel="noopener">USACO</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">This means that certain bit operations can exploit these definitions</span><br><span class="line">of negation and subtraction to yield interesting results, the proofs</span><br><span class="line">of which are left to the reader (see [a table of</span><br><span class="line">these](http://realtimecollisiondetection.net/blog/?p=78) offsite):</span><br><span class="line"></span><br><span class="line">             Binary</span><br><span class="line">Value        Sample             Meaning</span><br><span class="line">  x         00101100        the original x value</span><br><span class="line">x &amp; -x      00000100        extract lowest bit set</span><br><span class="line">x | -x      11111100        create mask for lowest-set-bit &amp; bits to its left</span><br><span class="line">x ^ -x      11111000        create mask bits to left of lowest bit set</span><br><span class="line">x &amp; (x-1)   00101000        strip off lowest bit set</span><br><span class="line">                            --&gt; useful to process words in O(bits set)</span><br><span class="line">                                instead of O(nbits in a word)</span><br><span class="line">x | (x-1)   00101111        fill in all bits below lowest bit set</span><br><span class="line">x ^ (x-1)   00000111        create mask for lowest-set-bit &amp; bits to its right</span><br><span class="line">~x &amp; (x-1)  00000011        create mask for bits to right of lowest bit set</span><br><span class="line">x | (x+1)   00101101        toggle lowest zero bit</span><br><span class="line">x / (x&amp;-x)  00001011        shift number right so lowest set bit is at bit 0</span><br><span class="line"></span><br><span class="line">There&apos;s no reason to memorize these expressions, but rather remember</span><br><span class="line">what&apos;s possible to refer back to this page for saving time when you</span><br><span class="line">processing bits.</span><br></pre></td></tr></table></figure></p></li><li><p>Graph<br>from <a href="http://train.usaco.org/usacotext2?a=0Ii18rWb43F&amp;S=graph" target="_blank" rel="noopener">USACO</a><br>邻接矩阵<span class="math inline">\(A\)</span>的<span class="math inline">\(K\)</span>次方的元素<span class="math inline">\(A^K(i,j)\)</span>表示从结点<span class="math inline">\(i\)</span>到结点<span class="math inline">\(j\)</span>恰好包含<span class="math inline">\(K\)</span>条边的路径的数目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The sample undirected graph would be represented by the following adjacency matrix:</span><br><span class="line"></span><br><span class="line">    V1  V2  V3  V4  V5  V6</span><br><span class="line">V1  0   0   1   0   0   1</span><br><span class="line">V2  0   0   0   0   1   0</span><br><span class="line">V3  1   0   0   1   0   1</span><br><span class="line">V4  0   0   1   0   0   0</span><br><span class="line">V5  0   1   0   0   0   0</span><br><span class="line">V6  1   0   1   0   0   0</span><br><span class="line">It is sometimes helpful to use the fact that the (i,j) entry of the adjacency matrix raised to the k-th power gives the number of paths from vertex i to vertex j consisting of exactly k edges.</span><br></pre></td></tr></table></figure></p></li><li><p>Dynamic programming</p><blockquote><p>The basic idea is to try to avoid solving the same problem or subproblem twice.</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;输入输出&lt;br&gt;
printf会把float隐式转换为double，所以两者的specifier都可以是&lt;code&gt;&#39;%f&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;function&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;int&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;long long&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;&#39;%d&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;code&gt;&#39;%lld&#39;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;&#39;%d&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;code&gt;&#39;%lld&#39;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;read a single character ignoring whitespace&lt;br&gt;
&lt;code&gt;scanf(&amp;quot; %c&amp;quot;, &amp;amp;c)&lt;/code&gt; place a whitespace before &lt;code&gt;%c&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://lvzhh.github.io/categories/Notes/"/>
    
    
      <category term="memo" scheme="http://lvzhh.github.io/tags/memo/"/>
    
  </entry>
  
  <entry>
    <title>BBST</title>
    <link href="http://lvzhh.github.io/2018/05/BBST/"/>
    <id>http://lvzhh.github.io/2018/05/BBST/</id>
    <published>2018-05-24T08:57:21.000Z</published>
    <updated>2018-05-24T09:03:45.753Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了一下各种BBST，简单总结一下。</p><p>Splay Tree：区间操作强无敌…对[l,r)区间的操作，把l-1结点splay到树根，r结点splay到根的右结点，则根的右结点的左子树就是区间[l,r)，然后对这棵子树进行操作。一个splay操作的均摊复杂度为O(logn)。</p><p>常见操作：[l,r)区间每个数加a，每个结点维护一个加的数值的lazy_tag</p><p>[l,r)区间翻转，每个结点维护一个表示是否翻转的标记</p><p>在第k个元素后插入元素或区间，若是区间，则要先建成一棵bst，把第k个结点splay到树根，第k+1个结点splay到根的右孩子，把需要插入的子树接到右孩子的左孩子。</p><p>删除元素，得到区间[l,r)后摘除子树。</p><p>实现：刚开始看时还纳闷为什么在实现时都要先加根节点以及根节点的右孩子，然后把整个区间建在根的右孩子的左子树上。后来才想到对于整个区间[1,N+1)，这种做法相当于在开始和结尾各添加一个元素，对整个区间进行操作则需要把这两个结点splay到树根和根的右孩子，才能得到整个区间。在第一个元素前和最后一个元素后插入都需要借助这两个结点。<br><a id="more"></a><br>ref: https://zhuanlan.zhihu.com/p/32090049?iam=5a347fde94eade0536f38c5e7434e822</p><p>http://blog.csdn.net/acm_cxlove/article/details/7800979</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">HDU <span class="number">3487</span> Play With Chain</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrclc ch[ch[root][1]][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, root;</span><br><span class="line"><span class="keyword">int</span> size[MAX_N], val[MAX_N], par[MAX_N], ch[MAX_N][<span class="number">2</span>], rev[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> nums[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// update x from its two children</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  size[x] = size[ch[x][<span class="number">0</span>]] + size[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the lazy tag down</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>;</span><br><span class="line">    rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">    rev[x] ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x will be changed to the pos of new node</span></span><br><span class="line"><span class="comment">// v val, p par</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  x = ++tot;</span><br><span class="line">  size[x] = <span class="number">1</span>;</span><br><span class="line">  val[x] = v;</span><br><span class="line">  par[x] = p;</span><br><span class="line">  ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  rev[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x points to new node</span></span><br><span class="line"><span class="comment">// interval [l, r), par p</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">  new_node(x, nums[m], p);</span><br><span class="line">  build(ch[x][<span class="number">0</span>], l, m, x);</span><br><span class="line">  build(ch[x][<span class="number">1</span>], m + <span class="number">1</span>, r, x);</span><br><span class="line">  push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  tot = root = <span class="number">0</span>;</span><br><span class="line">  size[<span class="number">0</span>] = val[<span class="number">0</span>] = par[<span class="number">0</span>] = ch[<span class="number">0</span>][<span class="number">0</span>] = ch[<span class="number">0</span>][<span class="number">1</span>] = rev[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  new_node(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  new_node(ch[root][<span class="number">1</span>], <span class="number">0</span>, root);</span><br><span class="line">  build(rrclc, <span class="number">1</span>, N + <span class="number">1</span>, ch[root][<span class="number">1</span>]);</span><br><span class="line">  push_up(ch[root][<span class="number">1</span>]);</span><br><span class="line">  push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// level x up through rotation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = par[x], g = par[p];</span><br><span class="line">  push_down(p); push_down(x);</span><br><span class="line">  <span class="keyword">int</span> tx = ch[p][<span class="number">0</span>] == x, tp = ch[g][<span class="number">0</span>] == p;</span><br><span class="line"></span><br><span class="line">  ch[p][!tx] = ch[x][tx];</span><br><span class="line">  <span class="keyword">if</span> (ch[x][tx]) par[ch[x][tx]] = p;</span><br><span class="line">  </span><br><span class="line">  ch[x][tx] = p; par[p] = x;</span><br><span class="line">  </span><br><span class="line">  par[x] = g;</span><br><span class="line">  <span class="keyword">if</span> (g) ch[g][!tp] = x;</span><br><span class="line"></span><br><span class="line">  push_up(p); push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// splay node x up until its par is r</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = par[x];</span><br><span class="line">  <span class="keyword">while</span> (p != r) &#123;</span><br><span class="line">    <span class="keyword">int</span> g = par[p];</span><br><span class="line">    <span class="keyword">if</span> (g == r) rotate(x); <span class="comment">// two level</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// three level</span></span><br><span class="line">      push_down(g); push_down(p);</span><br><span class="line">      <span class="keyword">int</span> tx = ch[p][<span class="number">0</span>] == x, tp = ch[g][<span class="number">0</span>] == p;</span><br><span class="line">      <span class="keyword">if</span> (tx == tp) rotate(p);</span><br><span class="line">      <span class="keyword">else</span> rotate(x);</span><br><span class="line">      rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    p = par[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r is the root of subtree</span></span><br><span class="line"><span class="comment">// k: the order of inorder tranverse</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_kth</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  push_down(r);</span><br><span class="line">  <span class="keyword">int</span> ls = size[ch[r][<span class="number">0</span>]], rs = size[ch[r][<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">if</span> (ls == k) <span class="keyword">return</span> r;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; ls) <span class="keyword">return</span> get_kth(ch[r][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> get_kth(ch[r][<span class="number">1</span>], k - ls - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  splay(get_kth(root, l - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, r + <span class="number">1</span>), root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cr = rrclc;</span><br><span class="line">  par[cr] = <span class="number">0</span>; rrclc = <span class="number">0</span>;</span><br><span class="line">  push_up(ch[root][<span class="number">1</span>]); push_up(root);</span><br><span class="line"></span><br><span class="line">  splay(get_kth(root, c), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, c + <span class="number">1</span>), root);</span><br><span class="line"></span><br><span class="line">  rrclc = cr; par[cr] = ch[root][<span class="number">1</span>];</span><br><span class="line">  push_up(ch[root][<span class="number">1</span>]); push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  splay(get_kth(root, l - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, r + <span class="number">1</span>), root);</span><br><span class="line">  rev[rrclc] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(r);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = q.size();</span><br><span class="line">    <span class="keyword">while</span> (s--) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">      <span class="keyword">if</span> (ch[x][<span class="number">0</span>]) q.push(ch[x][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (ch[x][<span class="number">1</span>]) q.push(ch[x][<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, val[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> first;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!r) <span class="keyword">return</span>;</span><br><span class="line">  push_down(r);</span><br><span class="line">  inorder(ch[r][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    first = !first;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, val[r]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, val[r]);</span><br><span class="line">  &#125;</span><br><span class="line">  inorder(ch[r][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M) &amp;&amp; N &gt; <span class="number">0</span> &amp;&amp; M &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) nums[i] = i;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (M--) &#123;</span><br><span class="line">      <span class="keyword">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">      <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        cut(a, b, c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        flip(a, b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(get_kth(root, <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    splay(get_kth(root, N + <span class="number">1</span>), root);</span><br><span class="line">    </span><br><span class="line">    first = <span class="literal">true</span>;</span><br><span class="line">    inorder(rrclc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// N = 10;</span></span><br><span class="line">  <span class="comment">// for (int i = 1; i &lt;= N; i++) nums[i] = i;</span></span><br><span class="line">  <span class="comment">// init();</span></span><br><span class="line">  <span class="comment">// splay(get_kth(root, 1), 0);</span></span><br><span class="line">  <span class="comment">// splay(get_kth(root, 5), root);</span></span><br><span class="line">  <span class="comment">// level(root);</span></span><br><span class="line">  <span class="comment">// inorder(root);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">POJ <span class="number">3580</span> SuperMemo</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrclc ch[ch[root][1]][0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, root;</span><br><span class="line"><span class="keyword">int</span> size[MAX_N], par[MAX_N], ch[MAX_N][<span class="number">2</span>], val[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rev[MAX_N], add[MAX_N], mi[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> nums[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lc = ch[x][<span class="number">0</span>], rc = ch[x][<span class="number">1</span>];</span><br><span class="line">  size[x] = size[lc] + size[rc] + <span class="number">1</span>;</span><br><span class="line">  mi[x] = min(val[x], min(mi[lc], mi[rc]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ch[x][<span class="number">0</span>]) rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch[x][<span class="number">1</span>]) rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">    rev[x] ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (add[x] != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch[x][i]) &#123;</span><br><span class="line">        add[ch[x][i]] += add[x];</span><br><span class="line">        val[ch[x][i]] += add[x];</span><br><span class="line">        mi[ch[x][i]] += add[x];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  x = ++tot;</span><br><span class="line">  size[x] = <span class="number">1</span>;</span><br><span class="line">  par[x] = p;</span><br><span class="line">  ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  val[x] = v;</span><br><span class="line">  rev[x] = <span class="number">0</span>;</span><br><span class="line">  add[x] = <span class="number">0</span>;</span><br><span class="line">  mi[x] = val[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_node</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (ch[x][<span class="number">0</span>]) del_node(ch[x][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (ch[x][<span class="number">1</span>]) del_node(ch[x][<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// tot--;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">  new_node(x, nums[m], p);</span><br><span class="line">  build(ch[x][<span class="number">0</span>], l, m, x);</span><br><span class="line">  build(ch[x][<span class="number">1</span>], m + <span class="number">1</span>, r, x);</span><br><span class="line">  push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  tot = <span class="number">-1</span>;</span><br><span class="line">  new_node(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  size[root] = <span class="number">0</span>; mi[root] = INF;</span><br><span class="line">  new_node(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  new_node(ch[root][<span class="number">1</span>], <span class="number">0</span>, root);</span><br><span class="line">  build(rrclc, <span class="number">1</span>, N + <span class="number">1</span>, ch[root][<span class="number">1</span>]);</span><br><span class="line">  push_up(ch[root][<span class="number">1</span>]);</span><br><span class="line">  push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = par[x], g = par[p]; <span class="comment">// if (p == 0) ?</span></span><br><span class="line">  push_down(p); push_down(x);</span><br><span class="line">  <span class="keyword">int</span> tx = ch[p][<span class="number">0</span>] == x, tp = ch[g][<span class="number">0</span>] == p;</span><br><span class="line"></span><br><span class="line">  ch[p][!tx] = ch[x][tx];</span><br><span class="line">  <span class="keyword">if</span> (ch[x][tx]) par[ch[x][tx]] = p;</span><br><span class="line"></span><br><span class="line">  ch[x][tx] = p; par[p] = x;</span><br><span class="line"></span><br><span class="line">  par[x] = g;</span><br><span class="line">  <span class="keyword">if</span> (g) ch[g][!tp] = x;</span><br><span class="line"></span><br><span class="line">  push_up(p); push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = par[x];</span><br><span class="line">  <span class="keyword">while</span> (p != r) &#123;</span><br><span class="line">    <span class="keyword">int</span> g = par[p];</span><br><span class="line">    <span class="keyword">if</span> (g == r) rotate(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      push_down(g); push_down(p);</span><br><span class="line">      <span class="keyword">int</span> tx = ch[p][<span class="number">0</span>] == x, tp = ch[g][<span class="number">0</span>] == p;</span><br><span class="line">      <span class="keyword">if</span> (tx == tp) rotate(p);</span><br><span class="line">      <span class="keyword">else</span> rotate(x);</span><br><span class="line">      rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    p = par[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_kth</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  push_down(r);</span><br><span class="line">  <span class="keyword">int</span> ls = size[ch[r][<span class="number">0</span>]], rs = size[ch[r][<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">if</span> (ls == k) <span class="keyword">return</span> r;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; ls) <span class="keyword">return</span> get_kth(ch[r][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> get_kth(ch[r][<span class="number">1</span>], k - ls - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert new node with val v after k</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  splay(get_kth(root, k), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, k + <span class="number">1</span>), root);</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  new_node(x, v, ch[root][<span class="number">1</span>]);</span><br><span class="line">  rrclc = x;</span><br><span class="line">  push_up(ch[root][<span class="number">1</span>]);</span><br><span class="line">  push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove [l, r) from splay tree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  splay(get_kth(root, l - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, r), root);</span><br><span class="line">  <span class="keyword">int</span> cr = rrclc;</span><br><span class="line">  rrclc = <span class="number">0</span>; par[cr] = <span class="number">0</span>;</span><br><span class="line">  push_up(ch[root][<span class="number">1</span>]);</span><br><span class="line">  push_up(root);</span><br><span class="line">  <span class="keyword">return</span> cr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazy_add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  splay(get_kth(root, l - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, r), root);</span><br><span class="line">  add[rrclc] += d;</span><br><span class="line">  mi[rrclc] += d;</span><br><span class="line">  val[rrclc] += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  splay(get_kth(root, l - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, r), root);</span><br><span class="line">  rev[rrclc] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revolve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = r - l;</span><br><span class="line">  t %= m;</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t += m;</span><br><span class="line">  <span class="keyword">int</span> c1 = remove(r - t, r - <span class="number">1</span>), c2 = remove(l, r - t);</span><br><span class="line">  <span class="comment">// (r - 1) =&gt; (l)</span></span><br><span class="line">  splay(get_kth(root, l - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, l + <span class="number">1</span>), root);</span><br><span class="line">  ch[rrclc][<span class="number">0</span>] = c1;</span><br><span class="line">  <span class="keyword">if</span> (c1) par[c1] = rrclc;</span><br><span class="line">  ch[rrclc][<span class="number">1</span>] = c2;</span><br><span class="line">  <span class="keyword">if</span> (c2) par[c2] = rrclc;</span><br><span class="line"></span><br><span class="line">  push_up(rrclc); push_up(ch[root][<span class="number">1</span>]); push_up(root);</span><br><span class="line">  <span class="comment">// reverse(l, r - t);</span></span><br><span class="line">  <span class="comment">// reverse(r - t, r);</span></span><br><span class="line">  <span class="comment">// reverse(l, r);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  splay(get_kth(root, l - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">  splay(get_kth(root, r), root);</span><br><span class="line">  push_down(rrclc);</span><br><span class="line">  <span class="keyword">return</span> mi[rrclc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(r);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = q.size();</span><br><span class="line">    <span class="keyword">while</span> (s--) &#123;</span><br><span class="line">      <span class="keyword">int</span> f = q.front(); q.pop();</span><br><span class="line">      <span class="keyword">if</span> (ch[f][<span class="number">0</span>]) q.push(ch[f][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (ch[f][<span class="number">1</span>]) q.push(ch[f][<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, val[f]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!r) <span class="keyword">return</span>;</span><br><span class="line">  push_down(r);</span><br><span class="line">  inorder(ch[r][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d "</span>, val[r]);</span><br><span class="line">  inorder(ch[r][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in.txt", "r", stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, nums + i);</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">  <span class="keyword">while</span> (M--) &#123;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'A'</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      lazy_add(a, b + <span class="number">1</span>, c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'R'</span> &amp;&amp; cmd[<span class="number">3</span>] == <span class="string">'E'</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">      reverse(a, b + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'R'</span> &amp;&amp; cmd[<span class="number">3</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      revolve(a, b + <span class="number">1</span>, c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'I'</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">      insert(a, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'D'</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a);</span><br><span class="line">      remove(a, a + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">      <span class="comment">// inorder(root); printf("\n");</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_min(a, b + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Treap：BST+heap，每个结点维护两个属性key,priority，结点的key满足bst，left.key&lt;x.key&lt;right.key；priority满足heap的性质，x.priority&lt;child.priority（若min heap）。相当于是首先把所有结点按照priority的大小从小到大排序，然后按照排序后的顺序依次插入bst。结点的priority是随机的，整个按照priority排序的序列相当于一个随机的序列，因n个关键字随机插入所构建的bst的高度期望是O(logn)，treap的高度的期望也是O(logn)。</p><p>一般treap可用来维护一个序列，给定x，查询x在序列排序后的位置；或给定位置k，查询元素x</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">POJ <span class="number">1442</span> Black Box</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = ~<span class="number">0U</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"><span class="keyword">int</span> A[MAX_M], u[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  Node *ch[<span class="number">2</span>], *par;</span><br><span class="line">  <span class="keyword">int</span> key, prio, size;</span><br><span class="line">  Node() &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_ch</span><span class="params">(Node* c, <span class="keyword">bool</span> tc)</span> </span>&#123;</span><br><span class="line">    ch[tc] = c;</span><br><span class="line">    c-&gt;par = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">tn</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> par-&gt;ch[<span class="number">1</span>] == <span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = ch[<span class="number">0</span>]-&gt;size + ch[<span class="number">1</span>]-&gt;size + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; Tnull, *null = &amp;Tnull;</span><br><span class="line"><span class="comment">// null's par and children may be modified</span></span><br><span class="line"></span><br><span class="line">Node mem[MAX_M], *ct = mem;</span><br><span class="line"></span><br><span class="line">Node* root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  ct-&gt;key = k;</span><br><span class="line">  ct-&gt;prio = rand();</span><br><span class="line">  ct-&gt;size = <span class="number">1</span>;</span><br><span class="line">  ct-&gt;ch[<span class="number">0</span>] = ct-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">  ct-&gt;par = null;</span><br><span class="line">  <span class="keyword">return</span> ct++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">  Node *p = x-&gt;par, *g = p-&gt;par; <span class="comment">// p != null</span></span><br><span class="line">  <span class="keyword">bool</span> tx = x-&gt;tn(), tp = p-&gt;tn();</span><br><span class="line">  <span class="comment">// p-&gt;set_ch(x-&gt;ch[!tx], tx);</span></span><br><span class="line">  p-&gt;ch[tx] = x-&gt;ch[!tx];</span><br><span class="line">  <span class="keyword">if</span> (x-&gt;ch[!tx] != null) x-&gt;ch[!tx]-&gt;par = p;</span><br><span class="line">  x-&gt;set_ch(p, !tx);</span><br><span class="line">  p-&gt;up();</span><br><span class="line">  x-&gt;up();</span><br><span class="line">  x-&gt;par = g;</span><br><span class="line">  <span class="keyword">if</span> (g != null) g-&gt;ch[tp] = x;</span><br><span class="line">  <span class="keyword">else</span> root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min heap</span></span><br><span class="line"><span class="comment">// x's left child.key &lt; x.key</span></span><br><span class="line"><span class="comment">// right child.key &gt;= x.key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  Node* x = new_node(k);</span><br><span class="line">  <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">    root = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* p = root;</span><br><span class="line">  <span class="keyword">while</span> (p != null) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; p-&gt;key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;ch[<span class="number">0</span>] == null) &#123;</span><br><span class="line">        p-&gt;set_ch(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;ch[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;ch[<span class="number">1</span>] == null) &#123;</span><br><span class="line">        p-&gt;set_ch(x, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p != null) &#123;</span><br><span class="line">    p-&gt;up();</span><br><span class="line">    p = p-&gt;par;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (x-&gt;par != null &amp;&amp; x-&gt;par-&gt;prio &gt; x-&gt;prio) &#123;</span><br><span class="line">    rotate(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">get_kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  Node* p = root;</span><br><span class="line">  <span class="keyword">while</span> (p != null) &#123;</span><br><span class="line">    <span class="keyword">int</span> ls = p-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (ls == k) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; ls) p = p-&gt;ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      k = k - ls - <span class="number">1</span>;</span><br><span class="line">      p = p-&gt;ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node* r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (r == null) <span class="keyword">return</span>;</span><br><span class="line">  inorder(r-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d "</span>, r-&gt;key);</span><br><span class="line">  inorder(r-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in.txt", "r", stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;M, &amp;N);</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);</span><br><span class="line">  <span class="comment">// for (int i = 1; i &lt;= M; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   insert(A[i]);</span></span><br><span class="line">  <span class="comment">//   inorder(root); printf("\n");</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, u + i);</span><br><span class="line">  u[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = u[i - <span class="number">1</span>] + <span class="number">1</span>; j &lt;= u[i]; j++) &#123;</span><br><span class="line">      insert(A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inorder(root); printf("\n");</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_kth(i - <span class="number">1</span>)-&gt;key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AVL Tree：nice的结构，在插入删除时进行旋转操作保证左右树高差不超过1</p><p>旋转操作比较复杂，总结一下即左高时右旋，若左子树右高，则左子树先左旋；右高时左旋，若右子树左高，则右子树先右旋。</p><p>AVL树与Treap一样都是用来实现BBST，还有红黑树，不过实现就有点复杂了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">SPOJ AVL Tree</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, val, size, height;</span><br><span class="line">    Node* ch[<span class="number">2</span>]; <span class="comment">// no par pointer =&gt; all rec</span></span><br><span class="line">    Node() : size(<span class="number">0</span>), height(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      size = ch[<span class="number">0</span>]-&gt;size + ch[<span class="number">1</span>]-&gt;size + <span class="number">1</span>;</span><br><span class="line">      height = max(ch[<span class="number">0</span>]-&gt;height, ch[<span class="number">1</span>]-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">()</span> </span>&#123; <span class="comment">// left.height - right.height</span></span><br><span class="line">      <span class="keyword">return</span> ch[<span class="number">0</span>]-&gt;height - ch[<span class="number">1</span>]-&gt;height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; Tnull, *null;</span><br><span class="line"></span><br><span class="line">  Node mem[MAX_N], *ct;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node* <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ct-&gt;key = key;</span><br><span class="line">    ct-&gt;val = val;</span><br><span class="line">    ct-&gt;size = <span class="number">1</span>;</span><br><span class="line">    ct-&gt;height = <span class="number">1</span>;</span><br><span class="line">    ct-&gt;ch[<span class="number">0</span>] = ct-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">    <span class="keyword">return</span> ct++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node* root;</span><br><span class="line"></span><br><span class="line">  AVLTree() &#123;</span><br><span class="line">    null = &amp;Tnull;</span><br><span class="line">    ct = mem;</span><br><span class="line">    root = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">      root = new_node(key, val);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    put(root, key, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node* <span class="title">put</span><span class="params">(Node* x, <span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == null) <span class="keyword">return</span> new_node(key, val);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key) &#123;</span><br><span class="line">      x-&gt;ch[<span class="number">0</span>] = put(x-&gt;ch[<span class="number">0</span>], key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;key &lt; key) &#123;</span><br><span class="line">      x-&gt;ch[<span class="number">1</span>] = put(x-&gt;ch[<span class="number">1</span>], key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x-&gt;val = val;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;up();</span><br><span class="line">    <span class="keyword">return</span> balance(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// t: 1 right rotation; 0 left rotation</span></span><br><span class="line">  <span class="function">Node* <span class="title">rotate</span><span class="params">(Node* x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    Node* c = x-&gt;ch[!t];</span><br><span class="line">    x-&gt;ch[!t] = c-&gt;ch[t];</span><br><span class="line">    c-&gt;ch[t] = x;</span><br><span class="line">    x-&gt;up();</span><br><span class="line">    c-&gt;up();</span><br><span class="line">    <span class="keyword">if</span> (root == x) root = c;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node* <span class="title">balance</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;bf() &lt; <span class="number">-1</span>) &#123; <span class="comment">// x right higher</span></span><br><span class="line">      <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>]-&gt;bf() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x-&gt;ch[<span class="number">1</span>] = rotate(x-&gt;ch[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      x = rotate(x, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;bf() &gt; <span class="number">1</span>) &#123; <span class="comment">// x left higher</span></span><br><span class="line">      <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>]-&gt;bf() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x-&gt;ch[<span class="number">0</span>] = rotate(x-&gt;ch[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      x = rotate(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node* x, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == null) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;key == key) <span class="keyword">return</span> x-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; x-&gt;key) &#123;</span><br><span class="line">      <span class="keyword">return</span> rank(x-&gt;ch[<span class="number">0</span>], key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> r = rank(x-&gt;ch[<span class="number">1</span>], key);</span><br><span class="line">      <span class="keyword">return</span> (r == <span class="number">-1</span>) ? r : x-&gt;ch[<span class="number">0</span>]-&gt;size + <span class="number">1</span> + r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == null) <span class="keyword">return</span>;</span><br><span class="line">    inorder(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, x-&gt;key);</span><br><span class="line">    inorder(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen("in.txt", "r", stdin);</span></span><br><span class="line">  AVLTree* t = <span class="keyword">new</span> AVLTree();</span><br><span class="line">  <span class="keyword">int</span> Q, type, n, r;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">  <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;type, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">      t-&gt;insert(n, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// t-&gt;inorder(t-&gt;root); printf("\n");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = t-&gt;rank(t-&gt;root, n);</span><br><span class="line">      <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Data tidak ada\n"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了一下各种BBST，简单总结一下。&lt;/p&gt;
&lt;p&gt;Splay Tree：区间操作强无敌…对[l,r)区间的操作，把l-1结点splay到树根，r结点splay到根的右结点，则根的右结点的左子树就是区间[l,r)，然后对这棵子树进行操作。一个splay操作的均摊复杂度为O(logn)。&lt;/p&gt;
&lt;p&gt;常见操作：[l,r)区间每个数加a，每个结点维护一个加的数值的lazy_tag&lt;/p&gt;
&lt;p&gt;[l,r)区间翻转，每个结点维护一个表示是否翻转的标记&lt;/p&gt;
&lt;p&gt;在第k个元素后插入元素或区间，若是区间，则要先建成一棵bst，把第k个结点splay到树根，第k+1个结点splay到根的右孩子，把需要插入的子树接到右孩子的左孩子。&lt;/p&gt;
&lt;p&gt;删除元素，得到区间[l,r)后摘除子树。&lt;/p&gt;
&lt;p&gt;实现：刚开始看时还纳闷为什么在实现时都要先加根节点以及根节点的右孩子，然后把整个区间建在根的右孩子的左子树上。后来才想到对于整个区间[1,N+1)，这种做法相当于在开始和结尾各添加一个元素，对整个区间进行操作则需要把这两个结点splay到树根和根的右孩子，才能得到整个区间。在第一个元素前和最后一个元素后插入都需要借助这两个结点。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="splay" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/splay/"/>
    
      <category term="treap" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/treap/"/>
    
      <category term="AVL" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/AVL/"/>
    
    
      <category term="template" scheme="http://lvzhh.github.io/tags/template/"/>
    
      <category term="HDU" scheme="http://lvzhh.github.io/tags/HDU/"/>
    
      <category term="POJ" scheme="http://lvzhh.github.io/tags/POJ/"/>
    
      <category term="SPOJ" scheme="http://lvzhh.github.io/tags/SPOJ/"/>
    
  </entry>
  
  <entry>
    <title>Link Cut Tree</title>
    <link href="http://lvzhh.github.io/2018/05/Link-Cut-Tree/"/>
    <id>http://lvzhh.github.io/2018/05/Link-Cut-Tree/</id>
    <published>2018-05-24T02:08:41.000Z</published>
    <updated>2018-06-08T07:37:36.868Z</updated>
    
    <content type="html"><![CDATA[<p>LCT用来维护<strong>有根树的森林</strong>。对任意结点v，Preferred Child（PC）的定义为：如果v没被访问过或者刚刚访问到v，则PC[v] = null；如果刚刚访问到v的孩子结点u所在的子树，则PC[v] = u。v到其preferred child（如果有）的边为preferred edge，preferred edge连接起来形成preferred path。需要表示的树（也就是直观上的树）称为represented tree。LCT把每一条preferred path维护成一个树，称为Auxiliary Tree，所用的数据结构为Splay Tree。</p><p>树链剖分是Heavy Light Decomposition，把一个结点的孩子分为重和轻，是按照树的结构来进行划分。LCT是Preferred Path Decomposition，是按照对结点的访问来划分的。<br><a id="more"></a><br>借用MIT 6.851课件的图：<br><img src="/2018/05/Link-Cut-Tree/0.png"></p><p>LCT的基本操作为access(v),make_root(v),link(v,w),cut(v,w)<br>in represented tree world:<br>access(v)把从根结点到v的路径变为preferred path<br>make_root(v)把v变为所在有根树的根结点<br>link(v,w)v是所在树的根结点，连接v和w<br>cut(v,w)去掉v和w之间的边</p><p>in Aux tree world:<br>实现上 见代码&gt;,&lt;<br>每个操作的复杂度为O(logn)，证明？</p><p>在每一个splay树中，相当于是把结点深度作为键值，进行中序遍历可得到从最接近根的结点到深度最大的结点的路径，即一条preferred path所对应的结点。<br>access(v)把根结点到v的路径上的所有结点放在一颗splay树中，如果维护路径上的信息，则可在这颗splay树的根结点获得统计信息。<br>如果要得到u到v的路径上的统计信息，可以先make_root(u)把u变为有根树的根结点，再access(v)把u到v的路径上的所有结点放在一个splay树中。<br>LCT是来解决动态树问题的，也就是树的结构在发生变化，不断有边的加入或边的消去。在树的结构发生变化的条件下树链剖分不太能做。</p><p>UOJ 3 魔法森林<br>按照A的值排序所有的边，按照排好的顺序依次向图中加入边，图中每条边的权值为此边的B值。加边的规则为：设边e的两端点是(u,v)，如果u,v不连通则加入e；如果连通，则查询u到v的路径上的最大权值b，如果b&gt;e.B，则去掉u-&gt;v路径上最大权值的边，加入e，否则不加入e。</p><p>每加入一条边e，查询1和N是否连通，如果连通则求出1到N的路径上最大权值，所求结果1-&gt;N的路径所对应的值（即最大A值+最大B值）r=min（e.A+1-&gt;N路径上的最大权值）。</p><p>证明：<br>按照加入边的规则，保证任意一对结点之间最多只有一条路径，也就是在加边的过程中，这个图是一个森林。</p><p>证明在加入边e之后的森林中1-&gt;N的路径所对应的值为min（e.A+1-&gt;N路径上的最大权值）：<br>如果加入e之前1-&gt;N不连通，加入e之后连通则1-&gt;N的路径上必包含e，此条路径所对应的值为（e.A+1-&gt;N路径上的最大权值）。<br>如果加入e之前1-&gt;N已经连通，加入e后，如果1-&gt;N的路径上包含e，则此条路径所对应的值为（e.A+1-&gt;N路径上的最大权值）。如果1-&gt;N的路径上不包含e，则（e.A+1-&gt;N路径上的最大权值）&gt;=（e1.A+1-&gt;N路径上的最大权值），e1为1-&gt;N的路径上A值最大的边，e1在e之前加入，有e.A&gt;=e1.A，则此次更新不影响结果。</p><p>粗略证明加边策略的正确性：<br>任意两点之间的最大权值尽可能小，这样才能使1-&gt;N路径上的最大权值尽可能减少，才能使1-&gt;N的路径所对应的值尽可能减少。</p><p>实现上，因为所维护的值在顶点上，把一条边作为一个顶点w，加入边e(u,v)时加入w-&gt;u和w-&gt;v两条边，去边e(u,v)时也是去两条。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = ~<span class="number">0U</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, A, B;</span><br><span class="line">&#125; es[MAX_M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Edge&amp; e1, <span class="keyword">const</span> Edge&amp; e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> e1.A &lt; e2.A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union set</span></span><br><span class="line"><span class="keyword">int</span> par[MAX_N], rank[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == par[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> par[x] = find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x = find(x);</span><br><span class="line">  y = find(y);</span><br><span class="line">  <span class="keyword">if</span> (rank[x] &lt; rank[y]) &#123;</span><br><span class="line">    par[x] = y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    par[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  Node *p, *ch[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> val, id, mx, mxid, rev, size;</span><br><span class="line">  Node() &#123;</span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == p-&gt;ch[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(Node* c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    ch[d] = c;</span><br><span class="line">    c-&gt;p = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">revIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rev ^= <span class="number">1</span>;</span><br><span class="line">    swap(ch[<span class="number">0</span>], ch[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;ch[<span class="number">0</span>] != <span class="keyword">this</span> &amp;&amp; p-&gt;ch[<span class="number">1</span>] != <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mx = val;</span><br><span class="line">    mxid = id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch[i]-&gt;mx &gt; mx) &#123;</span><br><span class="line">        mx = ch[i]-&gt;mx;</span><br><span class="line">        mxid = ch[i]-&gt;mxid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size = ch[<span class="number">0</span>]-&gt;size + ch[<span class="number">1</span>]-&gt;size + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev) &#123;</span><br><span class="line">      ch[<span class="number">0</span>]-&gt;revIt();</span><br><span class="line">      ch[<span class="number">1</span>]-&gt;revIt();</span><br><span class="line">      rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Tnull, *null = &amp;Tnull;</span><br><span class="line">Node npool[MAX_N + MAX_M], *V[MAX_N + MAX_M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    par[i] = i;</span><br><span class="line">    rank[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N + M; i++) &#123;</span><br><span class="line">    Node* v = npool + i;</span><br><span class="line">    V[i] = v;</span><br><span class="line">    v-&gt;p = null;</span><br><span class="line">    v-&gt;ch[<span class="number">0</span>] = null;</span><br><span class="line">    v-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">    v-&gt;val = i &gt; N ? es[i - N].B : <span class="number">0</span>; </span><br><span class="line">    v-&gt;id = i &gt; N ? i - N : <span class="number">0</span>;</span><br><span class="line">    v-&gt;mx = v-&gt;val;</span><br><span class="line">    v-&gt;mxid = v-&gt;id;</span><br><span class="line">    v-&gt;rev = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">  Node* p = x-&gt;p;</span><br><span class="line">  <span class="keyword">int</span> d = x-&gt;d();</span><br><span class="line">  p-&gt;push_down();</span><br><span class="line">  x-&gt;push_down();</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;is_root()) &#123;</span><br><span class="line">    x-&gt;p = p-&gt;p;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;p-&gt;setc(x, p-&gt;d());</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;setc(x-&gt;ch[!d], d);</span><br><span class="line">  x-&gt;setc(p, !d);</span><br><span class="line">  p-&gt;push_up();</span><br><span class="line">  <span class="comment">// x-&gt;push_up();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">  x-&gt;push_down();</span><br><span class="line">  <span class="keyword">while</span> (!x-&gt;is_root()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;p-&gt;is_root()) &#123;</span><br><span class="line">      rotate(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x-&gt;d() == x-&gt;p-&gt;d() ? rotate(x-&gt;p) : rotate(x);</span><br><span class="line">      rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  x-&gt;push_up();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(Node* v)</span> </span>&#123;</span><br><span class="line">  Node* t = null;</span><br><span class="line">  <span class="keyword">while</span> (v != null) &#123;</span><br><span class="line">    splay(v);</span><br><span class="line">    v-&gt;ch[<span class="number">1</span>] = t;</span><br><span class="line">    v-&gt;push_up();</span><br><span class="line">    t = v;</span><br><span class="line">    v = v-&gt;p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(Node* v)</span> </span>&#123;</span><br><span class="line">  access(v);</span><br><span class="line">  splay(v);</span><br><span class="line">  v-&gt;revIt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(Node* v, Node* u)</span> </span>&#123;</span><br><span class="line">  make_root(v);</span><br><span class="line">  v-&gt;p = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(Node* v, Node* u)</span> </span>&#123;</span><br><span class="line">  make_root(v);</span><br><span class="line">  access(u);</span><br><span class="line">  splay(u);</span><br><span class="line">  v-&gt;p = null;</span><br><span class="line">  u-&gt;ch[<span class="number">0</span>] = null;</span><br><span class="line">  u-&gt;push_up();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">query</span><span class="params">(Node* v, Node* u)</span> </span>&#123;</span><br><span class="line">  make_root(v);</span><br><span class="line">  access(u);</span><br><span class="line">  splay(u);</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, A, B;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;u, &amp;v, &amp;A, &amp;B);</span><br><span class="line">    es[i] = (Edge)&#123;u, v, A, B&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(es + <span class="number">1</span>, es + M + <span class="number">1</span>, comp);</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">int</span> res = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">    Edge&amp; e = es[i];</span><br><span class="line">    <span class="keyword">int</span> u = e.u, v = e.v;</span><br><span class="line">    <span class="keyword">if</span> (same(u, v)) &#123;</span><br><span class="line">      Node* q = query(V[u], V[v]);</span><br><span class="line">      <span class="keyword">if</span> (q-&gt;mx &gt; e.B) &#123;</span><br><span class="line">        <span class="comment">// cause q-&gt;mxid maybe changed in cut and link ops</span></span><br><span class="line">        <span class="keyword">int</span> mxid = q-&gt;mxid;</span><br><span class="line">        Edge&amp; e1 = es[mxid];</span><br><span class="line">        <span class="keyword">int</span> u1 = e1.u, v1 = e1.v;</span><br><span class="line">        cut(V[u1], V[N + mxid]);</span><br><span class="line">        cut(V[v1], V[N + mxid]);</span><br><span class="line">        link(V[u], V[N + i]);</span><br><span class="line">        link(V[v], V[N + i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      unite(u, v);</span><br><span class="line">      link(V[u], V[N + i]);</span><br><span class="line">      link(V[v], V[N + i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (same(<span class="number">1</span>, N)) &#123;</span><br><span class="line">      <span class="comment">// query path from 1 to N</span></span><br><span class="line">      res = min(res, e.A + query(V[<span class="number">1</span>], V[N])-&gt;mx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res == INF ? <span class="number">-1</span> : res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BZOJ 2049 Cave 洞穴勘测<br>LCT模板题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">    Result: Accepted</span><br><span class="line">    Time:<span class="number">1632</span> ms</span><br><span class="line">    Memory:<span class="number">1488</span> kb</span><br><span class="line">****************************************************************/</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  Node *p, *ch[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> rev;</span><br><span class="line">  Node() &#123;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == p-&gt;ch[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setc</span><span class="params">(Node* c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    ch[d] = c;</span><br><span class="line">    c-&gt;p = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">revIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rev ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_root</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;revIt();</span><br><span class="line">      ch[<span class="number">0</span>]-&gt;revIt();</span><br><span class="line">      ch[<span class="number">1</span>]-&gt;revIt();</span><br><span class="line">      swap(ch[<span class="number">0</span>], ch[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Tnull, *null = &amp;Tnull;</span><br><span class="line">Node mem[MAX_N], *C = mem, *V[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> Node::is_root() &#123;</span><br><span class="line">  <span class="comment">// return p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this;</span></span><br><span class="line">  <span class="keyword">return</span> p == null || (p-&gt;ch[<span class="number">0</span>] != <span class="keyword">this</span> &amp;&amp; p-&gt;ch[<span class="number">1</span>] != <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C-&gt;p = null;</span><br><span class="line">  C-&gt;ch[<span class="number">0</span>] = null;</span><br><span class="line">  C-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">  C-&gt;rev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> C++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    V[i] = new_node();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">  Node* p = x-&gt;p;</span><br><span class="line">  p-&gt;push_down();</span><br><span class="line">  x-&gt;push_down();</span><br><span class="line">  <span class="keyword">int</span> d = x-&gt;d();</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;is_root()) &#123;</span><br><span class="line">    x-&gt;p = p-&gt;p;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;p-&gt;setc(x, p-&gt;d());</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;setc(x-&gt;ch[!d], d);</span><br><span class="line">  x-&gt;setc(p, !d);</span><br><span class="line">  p-&gt;push_up();</span><br><span class="line">  <span class="comment">// x-&gt;push_up();</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">  x-&gt;push_down();</span><br><span class="line">  <span class="keyword">while</span> (!x-&gt;is_root()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;p-&gt;is_root()) &#123;</span><br><span class="line">      rotate(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x-&gt;d() == x-&gt;p-&gt;d() ? rotate(x-&gt;p) : rotate(x);</span><br><span class="line">      rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  x-&gt;push_up();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(Node* v)</span> </span>&#123;</span><br><span class="line">  Node* t = null;</span><br><span class="line">  <span class="keyword">while</span> (v != null) &#123;</span><br><span class="line">    splay(v);</span><br><span class="line">    v-&gt;ch[<span class="number">1</span>] = t;</span><br><span class="line">    v-&gt;push_up();</span><br><span class="line">    t = v;</span><br><span class="line">    v = v-&gt;p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(Node* v)</span> </span>&#123;</span><br><span class="line">  access(v);</span><br><span class="line">  splay(v);</span><br><span class="line">  v-&gt;revIt();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Node* <span class="title">find_root</span><span class="params">(Node* v)</span> </span>&#123;</span><br><span class="line">  access(v);</span><br><span class="line">  splay(v);</span><br><span class="line">  Node* r = v;</span><br><span class="line">  <span class="keyword">while</span> (r-&gt;ch[<span class="number">0</span>] != null) r = r-&gt;ch[<span class="number">0</span>];</span><br><span class="line">  splay(r);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(Node* v, Node* w)</span> </span>&#123;</span><br><span class="line">  make_root(v);</span><br><span class="line">  <span class="comment">// if (find_root(w) == v) return;</span></span><br><span class="line">  v-&gt;p = w;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(Node* v, Node* u)</span> </span>&#123;</span><br><span class="line">  make_root(v);</span><br><span class="line">  <span class="comment">// if (find_root(u) != v) return;</span></span><br><span class="line">  access(u);</span><br><span class="line">  splay(u);</span><br><span class="line">  v-&gt;p = null;</span><br><span class="line">  u-&gt;ch[<span class="number">0</span>] = null;</span><br><span class="line">  u-&gt;push_up();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(Node* v, Node* u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> find_root(v) == find_root(u);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">  build();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %d %d"</span>, cmd, &amp;u, &amp;v);</span><br><span class="line">    <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, query(V[u], V[v]) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">      <span class="comment">// if u v already connect</span></span><br><span class="line">      link(V[u], V[v]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if u v don't connect</span></span><br><span class="line">      cut(V[u], V[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LCT用来维护&lt;strong&gt;有根树的森林&lt;/strong&gt;。对任意结点v，Preferred Child（PC）的定义为：如果v没被访问过或者刚刚访问到v，则PC[v] = null；如果刚刚访问到v的孩子结点u所在的子树，则PC[v] = u。v到其preferred child（如果有）的边为preferred edge，preferred edge连接起来形成preferred path。需要表示的树（也就是直观上的树）称为represented tree。LCT把每一条preferred path维护成一个树，称为Auxiliary Tree，所用的数据结构为Splay Tree。&lt;/p&gt;
&lt;p&gt;树链剖分是Heavy Light Decomposition，把一个结点的孩子分为重和轻，是按照树的结构来进行划分。LCT是Preferred Path Decomposition，是按照对结点的访问来划分的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://lvzhh.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树" scheme="http://lvzhh.github.io/categories/%E5%9B%BE%E8%AE%BA/%E6%A0%91/"/>
    
      <category term="link cut tree" scheme="http://lvzhh.github.io/categories/%E5%9B%BE%E8%AE%BA/%E6%A0%91/link-cut-tree/"/>
    
    
      <category term="template" scheme="http://lvzhh.github.io/tags/template/"/>
    
      <category term="UOJ" scheme="http://lvzhh.github.io/tags/UOJ/"/>
    
      <category term="BZOJ" scheme="http://lvzhh.github.io/tags/BZOJ/"/>
    
  </entry>
  
  <entry>
    <title>UVA 10820 Send a Table</title>
    <link href="http://lvzhh.github.io/2018/05/UVA-10820-Send-a-Table/"/>
    <id>http://lvzhh.github.io/2018/05/UVA-10820-Send-a-Table/</id>
    <published>2018-05-22T13:06:31.000Z</published>
    <updated>2018-05-24T08:50:38.594Z</updated>
    
    <content type="html"><![CDATA[<p>所有可能的数对数量为N×N<br>所求的（x，y）一定满足x，y互素，否则设公约数为t，（x，y）可由（x/t，y/t）得到<br>若（x，y）互素，那么（y，x）也互素<br>若能求出满足1&lt;=x&lt;=N，1&lt;=y&lt;=x的互素的（x，y），那么经过对称即可得到所有的数对（可从N×N的二维图上来理解）</p><p>求phi值时注意避免溢出<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> phi[MAX_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler_function</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) phi[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// phi[i] == i, then i is prime</span></span><br><span class="line">    <span class="keyword">if</span> (phi[i] != i) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= N; j += i) &#123;</span><br><span class="line">      <span class="comment">// first / i then * (i - 1)</span></span><br><span class="line">      <span class="comment">// ensures phi[j] &lt;= j and no overflow</span></span><br><span class="line">      phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  euler_function(MAX_N);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N) &amp;&amp; N) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) res += phi[i];</span><br><span class="line">    res = res * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有可能的数对数量为N×N&lt;br&gt;
所求的（x，y）一定满足x，y互素，否则设公约数为t，（x，y）可由（x/t，y/t）得到&lt;br&gt;
若（x，y）互素，那么（y，x）也互素&lt;br&gt;
若能求出满足1&amp;lt;=x&amp;lt;=N，1&amp;lt;=y&amp;lt;=x的互素的（x，y），那么经过对称即可得到所有的数对（可从N×N的二维图上来理解）&lt;/p&gt;
&lt;p&gt;求phi值时注意避免溢出&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="欧拉函数" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="template" scheme="http://lvzhh.github.io/tags/template/"/>
    
      <category term="UVA" scheme="http://lvzhh.github.io/tags/UVA/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1402. A * B Problem Plus(FFT)</title>
    <link href="http://lvzhh.github.io/2018/05/HDU-1402-A-B-Problem-Plus-FFT/"/>
    <id>http://lvzhh.github.io/2018/05/HDU-1402-A-B-Problem-Plus-FFT/</id>
    <published>2018-05-22T13:01:55.000Z</published>
    <updated>2018-05-24T08:52:39.503Z</updated>
    
    <content type="html"><![CDATA[<p>递归版本的FFT还是好写…<br>输出结果时，注意特殊情况0*0=0<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; Comp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Comp <span class="title">I</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> M_PI</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> M_PI 3.14159265358979323846</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">Comp tmp[<span class="number">1</span> &lt;&lt; <span class="number">17</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Comp* a, <span class="keyword">int</span> n, <span class="keyword">int</span> rev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    tmp[i] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">      a[n / <span class="number">2</span> + i / <span class="number">2</span>] = tmp[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      a[i / <span class="number">2</span>] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  Comp *a0 = a, *a1 = a + n / <span class="number">2</span>;</span><br><span class="line">  DFT(a0, n / <span class="number">2</span>, rev);</span><br><span class="line">  DFT(a1, n / <span class="number">2</span>, rev);</span><br><span class="line">  </span><br><span class="line">  <span class="function">Comp <span class="title">cur</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">double</span> alpha = <span class="number">2</span> * M_PI / n * rev;</span><br><span class="line">  Comp step = <span class="built_in">exp</span>(I * alpha);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n / <span class="number">2</span>; k++) &#123;</span><br><span class="line">    tmp[k] = a0[k] + cur * a1[k];</span><br><span class="line">    tmp[k + n / <span class="number">2</span>] = a0[k] - cur * a1[k];</span><br><span class="line">    cur *= step;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a[i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> A[MAX_N], B[MAX_N];</span><br><span class="line">Comp a[<span class="number">1</span> &lt;&lt; <span class="number">17</span>] = &#123; &#125;, b[<span class="number">1</span> &lt;&lt; <span class="number">17</span>] = &#123; &#125;;</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">1</span> &lt;&lt; <span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, A, B) != EOF) &#123;</span><br><span class="line">    <span class="keyword">int</span> lA = <span class="built_in">strlen</span>(A), lB = <span class="built_in">strlen</span>(B);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; lA + lB) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      a[i] = <span class="number">0</span>;</span><br><span class="line">      b[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lA; i++) &#123;</span><br><span class="line">      a[i] = A[lA - <span class="number">1</span> - i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lB; i++) &#123;</span><br><span class="line">      b[i] = B[lB - <span class="number">1</span> - i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FFT</span></span><br><span class="line">    DFT(a, n, <span class="number">1</span>);</span><br><span class="line">    DFT(b, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      a[i] *= b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    DFT(a, n, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      a[i] /= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res processing</span></span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">      res[i] += <span class="keyword">int</span>(a[i].real() + <span class="number">0.5</span>);</span><br><span class="line">      res[i + <span class="number">1</span>] = res[i] / <span class="number">10</span>;</span><br><span class="line">      res[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (res[k] == <span class="number">0</span>) k--;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, res[k--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Reference：http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-12</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;递归版本的FFT还是好写…&lt;br&gt;
输出结果时，注意特殊情况0*0=0&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="快速傅里叶变换" scheme="http://lvzhh.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
    
      <category term="template" scheme="http://lvzhh.github.io/tags/template/"/>
    
      <category term="HDU" scheme="http://lvzhh.github.io/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lvzhh.github.io/2018/05/hello-world/"/>
    <id>http://lvzhh.github.io/2018/05/hello-world/</id>
    <published>2018-05-21T13:13:23.000Z</published>
    <updated>2018-05-24T09:10:27.690Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;
&lt;h3 id=&quot;create-a-new-post&quot;&gt;Create a new post&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
